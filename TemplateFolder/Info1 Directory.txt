# About this tutorial

What you're reading now is a Jupyter notebook. It's an interactive document containing a mix of text and Python program snippets. You can edit and run any cell. You may want to modify the python snippets to try how editing them influences the outcome and to get a feel for what is going on.

Since we're going quite fast, you're not expected to remember everything right away. Please review the tutorial at your own pace!
# Programming in Python

A program is essentially a "playbook" instructing the computer what to do in different situations. Here is a simple program that outputs a sentence describing Bob's average grade:
from statistics import mean

def show_mean(name, grades):
    return f"{name.capitalize()}'s mean grade is {mean(grades)}"
    
print(show_mean("bob", [4.0, 5.25, 6.0, 4.25, 4.0]))
If you've installed Python, you could store this program in a raw text file, for example called `grades.py` and then execute it by running `python grades.py`. Python will execute the program statement by statement and then exit.

## Interpreter / Shell

Instead of running a whole program, you can also interact with Python interactively, one statement at a time. When you run `python` without any additional arguments, you are dropped into the **interactive** Python shell.

You can follow along with this tutorial either in your own Jupyter notebook or in the interactive Python shell.

If you have neither Jupyter nor Python working yet, you can try using an online Python shell as a stop-gap for now: https://pythonhow.com/python-shell


# The Building Blocks of Programming

Before we get into the weeds of how to program in Python, specifically, let's get our bearings. For the purpose of this entry-level course, it's not wrong to say that programming is essentially made up of three main aspects: syntax, data and behavior.

## Syntax

Syntax specifies how you must formulate your program. It specifies rules on what each character means in which context. Different programming languages use different syntax. For example, `1 + 1` is syntactically correct, while `1 plus 1` is not.

You will learn the Python syntax step by step as you learn new concepts and techniques.

## Data

Data can go into a program; data is stored and modified while a program is running, and data can be written out when a program is finished. Data can come in a variety of shapes and sizes:

 * Simple data, such as numbers and characters: `0`, `1`, `0.5`, `True`, `False`, `"H"`
 * Basic data structures, such as strings: `"Hello"`, lists: `[1,2,"Hello"]`, maps (dictionaries): `{"Police": 117, "Ambulance": 144, "Firefighters": 118}` or sets: `{"Red", "Green", "Blue"}`
 * Complex data types (classes and objects) which can represent specific things: `c = Car("Ford", "Focus", 1994); c.honk()`

## Behavior

Behavior determines what the program actually does. As a programmer, you can influence the behavior of the program in any number of ways:

 * Functions, like in maths, take parameters as input and produce results a.k.a. "return values" as output.
 * Control flow steers behavior based on conditions
 * Abstractions & Polymorphism: separating abstract behavior (e.g., "transport") from concrete behavior (e.g., "by train", "on foot", etc.)

In this course, you will learn most of Python's syntax, different ways of representing data, and some techniques to define behavior. However, we will really only scratch the surface of what's possible.
# Functions

Functions are the bread and butter of programming in Python, and the most important building block to understand well.

Many real-world processes work based on input and output. For example, input electricity, ground coffee and water into a *coffe maker* function, you'll end up with espresso as output.

<div>
<img src="coffee_maker.png" width="300"/><img src="frother.png" width="210"/>
</div>
Naturally, multiple functions can be chained or otherwise composed:

<div>
<img src="macchiato.png" width="510"/>
</div>
You already know functions from maths.

<div>
<img src="function.png" width="100"/>
</div>
Here's how you would write $f(x) = x^{2}$ in Python:
def f(x):
    return x**2
A function definition starts with `def` followed by the name of the function. A function takes zero or more parameter. In this case, the function takes exactly one parameter, which we call `x`. The function then returns the square of `x`.

Note that just defining this function doesn't really *do* anything. We just defined some functionality, but we haven't used it yet. Let's try using it with a given $x$ now:
f(6)
Although when programming, you probably want to use a more descriptive name:
def power2(x):
    return x**2
power2(6)
From here on out, whenever you see a function, try to visualize or otherwise recognize its features: What it takes and what it returns.
<div>
<img src="power2_no-side-effect.png" width="200"/>
</div> 
In maths, you know functions mostly as dealing with numbers, receiving some numbers as input, and producing another number as output. However, in the real world, we need to perform all kinds of transformations, not just numerical ones.

Here's a slightly more interesting function that transforms three numbers (year, month and day) into a sentence:
def birthday_as_string(year, month, day):
    return f"This person was born on {day}.{month}.{year}"
It receives these three inputs as parameters, and returns not a number, but a sentence.
birthday_as_string(1999,7,13)
birthday_as_string(2305,7,13)
As you can see, *calling* the `birthday_as_string` function returns a character sequence as expected. 

<div>
<img src="birthday_as_string.png" width="500"/>
</div> 

Note that in this particular implementation, Python has **no intrinsic understanding** that it is dealing with a date here! Thus, we could call the function with invalid numbers:
birthday_as_string(-1999,13,45)
**We** decided to name the function `birthday_as_string` and to name the three function parameters `year`, `month` and `day`, but this has no meaning to Python, so the following program behaves exactly the same:
def bake_cookies(sr71, plums, x):
    return f"This person was born on {sr71}.{plums}.{x}"
bake_cookies(1999,7,13)
Also note that we **must** use the `return` keyword to indicate what the function should return when called. If we forget the `return`, then the function returns *nothing*:
def birthday_as_string(year, month, day):
    f"This person was born on {day}.{month}.{year}"   # missing return keyword
birthday_as_string(1999,7,13)                         # nothing is printed below because the call returned nothing
Of course you can have functions that take no parameters. These would be "constant" functions in Maths:
def pi_to_10_digits():
    return 3.1415926535
pi_to_10_digits()
Python ships with many [built-in functions](https://docs.python.org/3/library/functions.html), which are at your disposal. Here are a few examples:
min(4,-5,10)              # return the smallest parameter
round(pi_to_10_digits())  # round to nearest integer number
chr(69)                   # get the unicode character for decimal 69
chr(0x1FAE0)              # get the unicode character for hexadecimal 1FAE0
And yet many other functions are hidden away in other *libraries*, for example:
from statistics import median
median([1, 100, 2, 600, 3])
from os import cpu_count
cpu_count()
For now, you need to remember that regular functions in Python:
 * Have a name
 * Take 0 or more named parameters
 * `return` something at the end
 * Can be executed, a.k.a. "called", by their name when appending the (zero or more) parameters in braces `(...)`
<span style="color:purple;font-weight:bold">Exercise</span>

 1. Write a function `power` that takes two numbers `base` and `exponent` as parameters and returns the value of `base` to the power of `exponent`. In other words, write $f(x,y) = x^{y}$ in Python.
 2. Call the function to compute $2^8$.

# exercise solution

### A quick word on imports

You can import functionality from a module called `math` in one of two ways:

You can either import individual members from a module without importing the entire module. For example, if you just want the `cos` function and `pi` from `math`:
from math import cos, pi

cos(2*pi)
Or you can import the module by name. This allows you to call its functionality using the dot-notation:
import math

math.cos(2*math.pi)
Also, you could import all the members from a module using the `*` notation. However, note that **this is usually discouraged**. Python follows the mantra of *explicit is better than implicit*, and when importing `*`, you don't explicitely name the members that you wish to use upon importing.
from math import *

log2(8)
So here, it would have been better to do `from math import log2`, or just `import math` and then use `math.log2`, thus staying *explicit*.

One more thing to note that using imports or dot-notation, you can generally access any member of a module. These members might have different types, for example `math.cos` is a function, but `math.pi` is a floating point number:
import math

print(type(math.cos))
print(type(math.pi))
<span style="color:purple;font-weight:bold">Exercise</span>

There is a module called `random`, which has a member `randrange`, which is a function. This function takes two numbers as parameters, and then returns a random number between those two numbers.

 1. Import the `randrange` function from the `random` module
 2. Call the `randrange` function with parameters `10` and `21` to generate a random number between 10 and 20
# exercise solution

# Expressions

An expression is any contiguous unit that can be executed individually. An expression can consist of several sub-expressions.

Examples for expressions:
 * `"Hello"`
 * `1`
 * `1 + 2` (an expression containing 2 sub-expressions)
 * `print(5)` (an expression containing 1 sub-expression)
 * `1 + 2 * 3 > 4` (an expression containing 7 sub-expressions)

On the other hand, the following is not an expression, because it cannot stand alone: `1 +`

<div>
<img src="expression_tree.png" width="500"/>
</div> 

If you're interested, you can actually ask Python how it parses any piece of code:
from ast import dump, parse
print(dump(parse("1 + 2*3 > 4"), indent=4))
# Types, Values and Variables

Depending on the data type, operations may have a different meaning. Adding two numbers...
3 + 3
Is not the same as adding two strings (i.e. text characters):
"3" + "3"
When it comes to working with types and values in python, there are a few things everyone should know:

* The basic scalar types `int`, `float`, (`complex`), `bool` and `NoneType`
* The most commonly used compound types `str`, `tuple`, `list` and `dict`
* The difference between **mutable** and **immutable** values
* How to assign values to variables
* The meaning of **references** (Week 4)
## Basic types
3          # int: integer number
3.5        # float: floating point number (not 100% precise!)
(2 + 3j)   # complex (we're not going to use this)
Note that anything after a `#` is considered a comment and ignored by Python.

By the way, you can always figure out the type of a value by using the `type` function:
type(3.5)
A few examples for doing operations on numbers:
-3       # negation

1 + 3    # addition

1 - 3    # subtraction

1 * 3    # multiplication

10 / 3   # division

10 // 3  # integer division

10 % 3   # modulo

5 ** 3   # exponent
Python uses the expected precedence rules:
1 + 2 * 3
Of course, you can use braces to group subexpressions as you wish:
(1 + 2) * 3
Regarding floats, you need to know that computations can be slighly imprecise! We might discuss the reasons later, but for now, be aware that when using floats, the end result may not be perfectly accurate. An example:
(0.1 + 0.1 + 0.1)
To round floats to integers, you generally want to use the `round` function:
round(3.5)
The [`math` module](https://docs.python.org/3/library/math.html) provides additional functions. For example, you could round up (`ceil`) or down (`floor`) explicitely
import math

math.ceil(1.1)
math.floor(1.9)
Note that you can also convert floats to ints using `int`, but this will always **prune** the fractional components, while `floor` always rounds down. This makes a difference when rounding negative numbers:
int(3.9)
int(-3.9)
math.floor(-3.9)
A few more examples from the math library:
print(math.gcd(6,9,81))
print(math.log(math.e))
print(math.log10(100))
print(math.cos(math.pi))
<span style="color:purple;font-weight:bold">Exercise</span>

Write a function `area` which computes the area of a circle ($\pi r^{2}$) given its radius. The function should take the radius of a circle as the only parameter and it should return the area of the circle as a float. Remember that you can import pi (to great precision) from the math module, rather than defining it yourself.
# exercise solution

### Boolean

Programming deals a lot with conditions, which are ultimately either `True` or `False`. 
True
False
The keywords `and` and `or` are used to create boolean expressions
True and False
False or True
And you can use `not` to invert the value:
not True
Watch out for precedence; `not` binds more strongly than `and` and `or`, but less strongly than `==` and other operators:
not False and False
not (False and False)
not 1 == 2
Expressions separated by `and` and `or` are evaluated left-to right. The evaluation really only goes on as long as necessary. This is called *short-circuiting*. Read up on the documentation: https://docs.python.org/3/library/stdtypes.html#truth-value-testing

<div>
<img src="and_or_not.png" width="600"/>
</div> 
<span style="color:purple;font-weight:bold">Exercise</span>

Consider the following code snippet, which defines three functions, which all take zero parameters and return a boolean:
def a():
    print("a")
    return True
def b():
    print("b")
    return False
def c():
    print("c")
    return True
b()
For all of the following expressions, consider:

 1. What is the result of the expression?
 2. Which of the three functions are actually getting called when executing the expression?

Think about it first, then try executing the expressions. When you run them, you will see which letters are printed on the command line, indicating which of the functions have been called. Make sure you understand why certain functions get called and others do not!
a() or b() or c()
(a() or b()) and c()
a() and b() or c()
a() or b() and c()
### Working with strings
A "string" is a sequence of characters. Python doesn't make a syntactic distinction between strings and individual characters. You can use both double and single quotes for both.
'Ã„'
"Hello"
But note that if you want to use either `'` or `"` as an actual part of the string, you will have to account for that:
"Hell's kitchen"
You could also *escape* the quotation character (by placing a backslash `\` in front of it) if you were to use the same character to start and end the string:
'This string is surrounded by \' so we have to escape \' inside with a backslash'
You can see that Jupyter Notebook decides to show this string using double quotes. But there are better ways to handle this than escaping: You can use *triple* single or double quotes, which comes in handy if you're going to use both kinds of quotation marks within the string:
"""Inside this string, I can use " and ' without any trouble"""
Note that all these variants just use different *syntax*, but are **entirely equivalent** (`==` checks for *equivalence*):
"Hell's" == 'Hell\'s' == '''Hell's''' == """Hell's"""
Python comes with many string manipulation functions. Have a look at the Python documentation to learn more: https://docs.python.org/3/library/stdtypes.html#string-methods

Some examples:
"hello".upper()
"hELLo".lower()
"hello".capitalize()
"  hello   ".lstrip()
Note an important difference to the functions we mentioned so far (like `birthday_as_string`, `min`, or `round`):

While a function like `round` takes a parameter (`round(3.5)`), the strings functions mentioned here all act directly on the string that we're calling them on: `"hello".upper()`. In other words, it's not `upper("hello")`. Instead, the `upper` function implicitly receives the calling element (`"hello"`) as its input parameter.
You can also learn all kinds of things about strings using such functions:
"hello".endswith("lo")
"3".isdigit()
To figure out, whether a string contains another string, use the `in` operator:
"el" in "hello"
<span style="color:purple;font-weight:bold">Exercise</span>

Write a function called `picture_name` which takes a string as the only parameter. The function should return the string with two modifications:
 * if the string ends with ".png" (case-insensitive), this should be removed
 * the string should be made uppercase

See the given expressions (which should all be `True`) for how the function should behave. Make sure to look at the Python string documentation, since there is a function `removesuffix` which you might want to use here.
# exercise solution

#print(picture_name("Picture.png") == "PICTURE")
#print(picture_name("Picture.PNG") == "PICTURE")
#print(picture_name("Something else") == "SOMETHING ELSE")
## Variable assignment
You can assign a value to a variable using the `=` operator:
name = "Alice"
Then you can use this variable in place of an actual value, for example:
print("Hello " + name + "!")
In Python, variables can always be reassigned, so there is no concept of `final`, `val` or `const`, like in some other languages. The previously assigned value is simply lost.
name = "Alice"
name = "Bob"
print("Hello " + name + "!")
You can also assign multiple variables at once using commas, which will come in handy later. Just make sure that the left and right side contain the same number of variables and values:
name, age = "Alice", 33
age
### Restrictions on variable and function names
Variable names can be many things, but there are some guidelines and restrictions you must know:
 * Typically you want your variable and function names to just contain characters, numbers and `_` (underscore)
 * Names are case sensitive (*bananA* is not the same name as *banana*)
 * You should use variable names that are meaningful. Excessive use of abbreviations is strongly discouraged.
 * Python naming convention for variable and function names is *all-lowercase separated by underscores*
   * Use `birthday_as_string`, not any of `BirthdayAsString`, `birthdayasstring`, or `birthdayAsString`
 * Write your code in English.
 * You cannot use *reserved keywords* as names:
   * `False`, `await`, `else`, `import`, `pass`, `None`, `break`, `except`, `in`, `raise`, `True`, `class`, `finally`, `is`, `return`, `and`, `continue`, `for`, `lambda`, `try`, `as`, `def`, `from`, `nonlocal`, `while`, `assert`, `del`, `global`, `not`, `with`, `async`, `elif`, `if`, `or`, `yield`
 * You should not, and sometimes cannot use certain names in certain contexts, read https://docs.python.org/3/reference/lexical_analysis.html#keywords for more information



## String interpolation

Often you will want to print values stored in variables. You've already seen that you can concatenate strings and vairables using `+`:
print("Hello " + name + "!")
However, this quickly becomes tedious and even problematic:
print(name + " is " + age + " years old")
Python complains because it's not possible to add an integer to a string. So instead, we should use one of Python's *three* ways of interpolating strings:

 * f-Strings
 * "old-style string interpolation" (using `%`)
 * the `.format()` function
 
These days, f-strings are the way to go, so today, we'll only look at those.
period = "years"
print(f"{name} is {age} {period} old")
String interpolation also gives you the ability to format individual values differently via the *Format String Syntax* (https://docs.python.org/3/library/string.html#format-string-syntax)

Probably the most common use is to format numbers. Here's an example where a floating point number is formatted, so that the number will be 6 digits long (including the decimal point, padding with leading zeroes if necessary) and have 2 digits after the decimal point:
age = 33.711922
print(f"{name} is {age:06.2f} years old")
Let's revisit our `birthday_as_string` function:
def birthday_as_string(year, month, day):
    return f"{day}.{month}.{year}"
birthday_as_string(1952,8,19)
At least around these parts of the world, you would expect the month to always comprise two digits (i.e., with a leading `0`). Using *printf-style* formatting, we can specify that the month should always be formatted using 2 digits, using `0` as the padding character:
def birthday_as_string(year, month, day):
    return f"{day}.{month:02}.{year}"
birthday_as_string(1952,8,19)
You don't need to know the string formatting syntax by heart! For now, just remember that it exists, and that you don't need to write a lot of code to change how numbers are formatted.
# Understanding error messages and finding help

Programming comes with a 100% guarantee for errors and ensuing frustration. Let's review the error message from before:
name = "Alice"
age = 44
print(name + " is " + age + " years old")
Generally, Python will try to help you out by giving you a code location and error message (typically the last line). You will want to enter that error into a search engine if you don't know what's happening.
# Collections

Collections are composite data structures that can contain other kinds of data and provide *some* structure and functionality out of the box. Different kinds of collections are suitable for different kinds of purposes.
## Tuples
Tuples are *array-like* collections which have a **fixed order** and **fixed length**. In Python, a tuple can contain a mix of arbitrary types; duplicate values are fine, too.
stuff = ("!", 2, 2, 5.5, "Hello", True, None)
stuff
## Indices and Slicing

Use brackets to access tuple or string elements; note that the first element is at index `0`
stuff[4] + stuff[0]
You can also use negative indices, which will be counted from the rear:
stuff[-3] + stuff[-7]
Instead of just selecting one element, you can also select entire ranges of values:
stuff[1:4]
Here's an example of using the built-in `sum` function, which takes an iterable (for example, a tuple) of numbers and sums them:
sum(stuff[1:4])
Note that of the two numbers used in defining the slice, the first index is included in the slice, while the second index is excluded, i.e. the range `[1:4]` will contain the second, third and fourth element, but not the fifth.

You can also omit the first or last index (or both!) and Python will just go until the beginning or end:
stuff[:3]
stuff[:]
Finally, you can get the length of a tuple or string using the `len` function:
len(stuff)
All of the above is true for strings as well:
sentence = "Hello, World!"
sentence[1]
sentence[-1]
sentence[3:5]
sentence[-6:]
len(sentence)
Here's how I visualize indices, maybe it also works for you: instead of considering the index numbers to be pointing *at* an element, I consider them pointing at the *gap* just before the referenced element. This works for both positive and negative indices:

<div>
<img src="indices.png" width="200"/>
</div> 
<span style="color:purple;font-weight:bold">Exercise</span>

Write a function `replace_prefix` which takes two strings `sentence` and `prefix` as parameters. The function should replace the first $n$ characters of `sentence` with `prefix` where $n$ corresponds to the length of `prefix`. You may assume that `sentence` is always at least as long as `prefix`. See the given expressions (which should all be `True`) for how the function should behave.
# exercise solution

#print(replace_prefix("abcdef", "xyz") == "xyzdef")
#print(replace_prefix("What is this?", "This") == "This is this?")
### Collection unpacking

We saw before that you can assign multiple variables on one line using commas. The same can be done with collections: specify the correct number of variable names on the left side and provide a collection with the same length on the right side.
record = ("Alice", 33, "alice@example.org")
name, age, email = record
print(email)
## Mutable vs. Immutable

Mutable means that data can be changed; immutable is the opposite: once something has been defined, it cannot be changed. We'll discuss the implications of this in a later lecture, but for now just be aware that some types in Python are inherently immutable.

The most prominent example for an **immutable** type is `str`: Strings cannot actually be changed, once they have been created.

sentence = "Hello"
print(sentence[0])
sentence[0] = "Y"

But what about the functions like `lower` or `capitalize` that we just saw? These are **not changing** the string itself, they are actually **returning a new** string!

This becomes readily apparent, when we use these functions on a string variable:
name = "aLiCe"
name.capitalize()
print(name)
It appears, as if `name.capitalize()` did not have any effect! That's because the string stored in `name` cannot be changed, and `capitalize()` does not change it. Strings are immutable! `capitalize()` instead **returns** a new string as a result. To use the changed value, we have to reassign it:
name = "aLiCe"
name = name.capitalize()
print(name)
Tuples are also immutable:
stuff = ("!", 2, 2, 5.5, "Hello", True, None)
print(stuff[1])
stuff[2] = 200
Immutability exists for several good reasons to do with performance and error-avoidance, and we'll discuss them in more detail in a future lecture.

For now, just remember that strings and tuples are immutable.
## Lists
Python offers *lists* as an alternative to tuples which *is* mutable. That means that lists have a **fixed order**, but **no fixed length**.

stuff = ["!", 2, 2, 5.5, "Hello", True, None]
stuff
Visibly, the only difference is that we use square brackets instead of braces. The usual indexing and slicing operators all work on lists, too:
print(stuff[4] + stuff[0])
print(stuff[-2:])
But in contrast to tuples, this list can be modified. For example, you could re-assign an element at a specific index:
stuff[0] = "???"
Now the first element has been replaced:
print(stuff)
You can also add or remove elements:
stuff.append("More stuff")
stuff
stuff.append(["another list with", "more", "elements"])
stuff
stuff.remove(2)   # Removes the first matching element
stuff
del(stuff[2])     # Removes an element at a specific index
stuff
### Tuple or List?

Tuples and lists are very similar. As a rule of thumb, use tuples if you're not going to modify the data. We're going to discuss the intricacies of immutability in another lecture.
<span style="color:purple;font-weight:bold">Exercise</span>

The following list `source` is given. Use assignment, `add`, `remove` and/or `del`, or any other means to transform the list so that is becomes equivalent to `target`. Do not reassign `source`!
# exercise solution

source = [2, 1, 1, "Hello", True, print, (1,2,3)]
target = [1, (1,2,3), "Hello", True]

# Modify source until it matches target:
# ...

# You can print source to see the modifications:
print(source)

# This should then be True
source == target
# Set

Sets are just that: sets of values in the mathematical sense:
 * Values in a set do not have any particular ordering
 * Each unique value appears in the set exactly once
colors = {"Red", "Blue", "Green"}
Sets in Python are *mutable*, so you can add and remove elements:
colors.add("Yellow")
colors.remove("Red")
colors
And because it's a set, adding the same value again has no effect:
colors.add("Yellow")
colors
Just like with tuples and lists, you can use the `in` keyword to check if a value is contained in a set:
"Blue" in colors
# (Almost) empty collections

If you ever need to create empty collections, you need to know the following syntax. Create an empty list:
l = []
Here's an empty tuple:
t = ()
Tuples are a bit special, because they use the same braces that are used for other things in Python. Consider this:
t = (3)
Is this a tuple containing a single integer? Actually, no:
t
It's just the number `3`. Why? Well, Python cannot really tell the difference between braces used to enclose expressions and braces used to create a tuple.
t = (((3) + (2)) * (5))
t
So if you really want to create a tuple that only contains a single value, you need to use the following syntax:
t = (3,)
t
Similarily, you might notice that an empty dictionary and an empty set would "look" the same, something like `{}`? So while you can create an empty dictionary using this notation, you will need to use the built-in `set()` function to create an empty set:
s = set()
s.add("Red")
s
# A note about the shell and `print`

When you type an expression into the Python shell, Python will evaluate the expression and show the resulting value on your command line. This is NOT the same thing as using the `print` function! If you use the print function, it will *also* print to the command line, but the in any case, the *result* of the entered expression is always shown at the end.

The Jupyter notebook works similarily, showing the result of the expression. Understand that only the result of the *entire* code is shown, not each individual expression. In other words, only the result of the last statement is shown. See these examples:
print("hello")
3.5+1
2+1
5+10
5+4
However, this only makes sense in the contex of using Jupyter or the interactive Python shell. If you would save these snippets in a file `example.py` and run it as `python example.py`, then only "hello" would be printed on your command line!
<span style="color:purple;font-weight:bold">Exercise</span>

 1. Evaluate the expression `1+10`
 2. Evaluate the expression `'A'`
 3. Execute a statement that prints `'A'`

Recognize the reason why both 2. and 3. *look similar*: Python evaluates the expression `'B'` and prints the result, which is just `'B'`. Python also evaluates the expression `print('A')` which explicitely prints the value given to the function (even when not using Jupyter or the interactive Python command line) but otherwise doesn't evaluate to anything, so `A` is all you see.
# excercise solution
# What you learned today

* Functions: they take zero or more parameters and return something: **Learn to recognize the input/output (params & types) of a function**
* What is an expression?
* Basic numbers: `int`, `float`
* Booleans, `and`/`or` and *shortcircuiting*
* Check the type of a value using the `type(...)` function
* Imports (`from module import something`)
* How to create and operate on strings
* Variables
* String interpolation (*f-strings*)
* Mutable vs. Immutable
* Collections:
  * Tuples and Lists
  * Sets

If some or all of this is new to you, please take 2-3 hours to go through this tutorial one more time.
 1. Modify code snippets to see how the outcome changes
 2. Write and execute your own snippets
 3. If you run into errors, look up the error message and find the related documentation in the Python API
# Quick recap from last week
### Functions:
  * A function takes zero or more parameters and returns something.
  * You can call a function by it's name and `(...)`.
  * To define a new function, you use the `def` keyword and accompanying syntax.
def hypothenuse(a, b):
    return (a**2 + b**2)**(1/2)

def get_first_three_characters_as_upper(word):
    return word[:3].upper()

print(hypothenuse(3, 4))
print(get_first_three_characters_as_upper("France"))
### Basic numbers: `int`, `float`

1 + 2
1.0 + 2
0.3 + 0.3 + 0.3 == 0.9       # floating point numbers aren't perfectly accurate
Remember that floats are not perfectly accurate. The [Python documentation](https://docs.python.org/3/tutorial/floatingpoint.html) has a great article with more information.
### Check the type of a value using the `type(...)` function

type(3.5)
type(hypothenuse)
### Imports
import datetime
datetime.datetime.now()
from os.path import splitext
splitext("picture.png")
### How to declare and operate on strings

"Pineapple"[-5:].capitalize()
### Variables

name = "Alice"
book = name + " in Wonderland"
name = "Bob"
book
### String interpolation (*f-strings*) and formatting
f'{name} is reading "{book}"'
from math import pi
f"Pi to the first 4 digits is {pi:.4f}"
digits = 6
f"Pi to the first {digits} digits is {pi:.{digits}f}"
### Tuples and Lists

stuff = (1, "hello", 2)       # fixed length, immutable
print(stuff[1])
print(stuff[-1])
stuff = [1, "hello", "hi"]    # mutable
print(stuff[1])
del(stuff[2])
stuff.append(3)
stuff.extend([4, 5])
print(stuff)
### Sets
my_set = {1, 2, 3, 4, 4, 4, 4, "hello"}
print(my_set)
my_set.remove(3)
my_set.add(4)
my_set.add(10)
print(my_set)
### Mutable vs. Immutable
 * lists are *mutable*
 * tuples and strings are *immutable*
mutable_list = [1, 2, 3, 3, 4]
mutable_list.remove(3)
print(list)
mutable_list.append(100)
mutable_list.extend([-1, -2, "hello"])
mutable_list
immutable_tuple = (1, 2, 3, 4)
# not possible:
# immutable_tuple.append(5)
changed_tuple = immutable_tuple + (5,)
changed_tuple
### Booleans, `and`/`or` and shortcircuiting


In last week's example, each of the following functions prints a character and then returns either True or False.
def a():
    print("a")
    return True
def b():
    print("b")
    return False
def c():
    print("c")
    return True
So when we construct an expression using these function calls, we can see which functions are called:
a() or b() and c()
In Python `and` takes precedence over `or` as described in the [Python Documentation](https://docs.python.org/3/reference/expressions.html#operator-precedence). Then why is only `a()` being called? Shouldn't the `and` operation be performed first, so at least `b()` should be called?

First, let's agree that `a() or b() and c()` in this case is equivalent to
True or False and True
Now, We can break down this problem into 3 axioms:

**#1** Operator precedence only determines where the implicit/invisible braces are placed.

So in...
True or False and True
...operator precedence places the braces like so:
True or (False and True)
Because the braces are placed like that, the resulting expression tree is:

<div>
<img src="bool-exp-tree.png" width="500"/>
</div>
It is true, that the `and` would need to be evaluated first, in order for the result to be available for the right-hand side of the `or` operation. However...

**#2** In a binary expression (like `and`, `or`, `+` or `**`) the left-hand operator is evaluated first.

So in...
True or (False and True)
...the left side (`True`) is evaluated first.

**#3** Short-circuiting: If the left operand of an or operation is True, the right side is not evaluated. Likewise, if the left operand of an and operation is False, the right side is not evaluated.

This means that in...
True or (False and True)
Only the left-hand operator is evaluated (because `True or ...` short-circuits). Likewise, in...
False and some_really_expensive_function_call_that_would_take_1_hour_to_complete(123)
only the left-hand operator is evaluated (because `False and ...` short-circuits. Short-circuiting is a special feature of `and` and `or`.

Here's another example using other kinds of binary operators. In...
1 + 2 * 3
operator precedence places the "invisible braces" like so:
1 + (2 * 3)
for an expression tree

<div>
<img src="arith-exp-tree.png" width="500"/>
</div>
Here, again, the left-hand side (`1`) is evaluated first. But unlike using `or`, we still have to evaluate the right side as well (no short-circuiting possible). Here it is using functions:
def a():
    print("a")
    return 1
def b():
    print("b")
    return 2
def c():
    print("c")
    return 3

a() + b() * c()
<p style="height:100px"></p>
<hr>
<p style="height:100px"></p>




# Useful built-in functionality

### `range` 
`range` is a collection that represents sequences of numbers (for example, `range(10)` represents `0` through `9`). Note that just calling range will not really *do* much. You just get a "range" object.
range(10)
type(range(10))
Only when you *need* the numbers will they be produced. For example, if we want a list of numbers:
list(range(10))
This is done because only the necessary number of elements will be produced one by one. This is called *lazy evaluation*.
super_big_range = range(10000000000000000000000000000000000000000000)
super_big_range[5:20]
list(super_big_range[5:20])
`range` also takes additional parameters to determine the start, end, step size, etc. See https://docs.python.org/3/library/stdtypes.html#typesseq-range
set(range(5, 20, 2))
tuple(range(21, 0, -3))
(don't convert ranges to lists, tuples or whatever unless necessary)
### `enumerate`

Use `enumerate` on a collection to create a sequence of tuples, where each tuple has two elements:
 * an index
 * an element from the collection
list(enumerate(["These", "are", "words", "in", "a", "list"]))
Just like `range`, `enumerate` on it's own doesn't *do* much and only evaluates when needed:
enumerate(["These", "are", "words", "in", "a", "list"])
enumerate(range(10000000000000000000000000000000000000000000))
Note that `enumerate` also works on collections that don't really have an inherent ordering, like sets:
list(enumerate({1, 100, 40, 88}))
A few more examples:
list(enumerate(range(5)))
"this is a       sentence".split()
tuple(enumerate("this is a sentence".split()))
`enumerate` also takes an additional parameter to change the starting index:
list(enumerate([10, 333, 30], 250))
### `sum`, `min`, and `max`

These functions can be used on collections of numbers to calculate their sum, minimum value or maximum value, respectively:
numbers = [12, 41, 2024, 3, -301, 0]
sum(numbers)
min(numbers)
max(numbers)
<span style="color:purple;font-weight:bold">Exercise</span>

1. Write an expression that calculates the sum of all numbers between 5 and 200.
2. Write an expression that creates a list of tuples, given a list of words `words`. Each tuple should contain an index and a word. The index for the first word should be `1`
# exercise 1 solution

# exercise 2 solution
words = "The original machine had a base-plate of prefabulated aluminite".split()

# Conditional statements for control flow: `if`, `elif`, and `else`

Oftentimes, you want your program behavior to vary depending on what data it receives. One mechanism to do so is *control flow* by means of `if`, `elif`, and `else` to decide whether to execute a given block of code.
number = 10
if number > 0:
    print("Greater than zero")
else:
    print("Not greater than zero")
The following variations of using if/elif/else are permitted:
 * Just an `if` block, alone. The code block gets executed if the condition is true, otherwise not. Here are two examples:
if 1 + 1 == 2:
    print("Math is easy")
    
if True == False:
    print("The universe is broken")
 * An `if` block followed by an `else` block. At least **one** of those two blocks will **always** be executed (unless the program crashes...), but **not the other**:
if True == False:
    print("The universe is broken")
else:
    print("Everything is OK")
 * An `if` block followed by any number of `elif` blocks, which just add more possible conditions and code blocks. Only the **first** block with a `True` condition will execute. If none of the conditions are true, none of the code blocks are executed:
number = 5
if number > 0:
    print("Number is greater than 0")
elif number > 3:
    print("Number is greater than 3")
If you wanted both blocks to execute, you could write the following. Note that these two `if` statements are entirely separate and have nothing to do with each other.
number = 5
if number > 0:
    print("Number is greater than 0")
if number > 3:
    print("Number is greater than 3")
 * An `if` block followed by zero or more `elif` blocks, followed by a final `else` block. Exactly **one** of these blocks will execute.
number = -5
if number > 0:
    print("Number is greater than 0")
elif number > 3:
    print("Number is greater than 3")
elif number > 5:
    print("Number is greater than 5")
else:
    print("None of the above")

Of course, this means, there can never be an `else` or `elif` block standing alone, only together with `if`. Here's another example. Observe that here, we have two separate pieces of code:
 * One `if` block (without anything else)
 * One `if` block together with an accompanying `else` block
number = -3
if number < 0:
    print("Less than zero")




if number < 10:
    print("Less than ten")
else:
    print("Greater than ten")
Generally speaking, keep your if/elif/else expressions short and obvious. You don't want to be debugging a christmas tree of conditions.
By the way... don't embarrass yourself:
def find_bob(names):
    if "Bob" in names:
        return True
    else:
        return False
names = ["Alice", "Bob", "Peter"]
find_bob(names)
should be
def find_bob(names):
    pass # what should it be?
names = ["Alice", "Bob", "Peter"]
find_bob(names)
A few more examples:
haystack = range(10)
needle = 30
if needle in haystack:
    print("30 found")
else:
    print("30 not found")
# A kiosk with a very limited selection...
menu = ["Banana", "Peach", 'Potato']
prices = [1.25, 1.75, 1.20]
selection = 1
if 0 <= selection < len(menu):
    print(f"A {menu[selection].lower()} costs {prices[selection]:.2f}")
else:
    print("Invalid selection")
### "Truthyness"

In many languages, certain values are automatically converted to a boolean if used in a boolean expression.
**Remember**: In Python, any value is considered `True`, except the following:
 * `False` and `None`
 * `0`, `0.0`, `0j`, `Decimal(0)`, `Fraction(0, 1)`
 * `''`, `()`, `[]`, `{}`, `set()`, `range(0)`
 * A few other values that are not so important right now

See the [Official documentation](https://docs.python.org/3/library/stdtypes.html#truth-value-testing) for all the details, or this [StackOverflow post](https://stackoverflow.com/a/39984051) for a casual list.

You can easily check which boolean something evaluates to by using the `bool` function:
bool(0)
bool(25)
bool(["not", "empty", "list"])
bool([])
bool("Just a string")
bool("")
That's why you can use an arbitrary value as the condition in an if statement, even if that value is not a boolean:
if 3+5:
    print("Banana")
if 3-3:
    print("Not going to happen")
This is most commonly done for differentiating between empty and populated collections:
names = []
if not names:
    print("No names!")
else:
    print(names)
<span style="color:purple;font-weight:bold">Exercise</span>

Write a function `sign` that takes a single integer as a parameter `number` and returns a string. If `number` is negative, the function should return `"negative"`, if `number` is positive, it should return `"positive"`, and otherwise it should return `"zero"`
# exercise solution

<span style="color:purple;font-weight:bold">Exercise</span>

Write a function `within` that takes two parameters:
 1. a single integer `target`
 2. a list of numbers `numbers`, which may be in any order

The function should return `True` if `target` is (strictly) between the smallest and largest values in `target`, otherwise it should return `False`
# exercise solution

# Maps (Dictionaries)

Let's look at the previous example with the mediocre kiosk:
# A kiosk with a very limited selection...
menu = ["Banana", "Peach", 'Potato']
prices = [1.25, 1.75, 1.20]
selection = 2
if 0 <= selection < len(menu):
    print(f"A {menu[selection].lower()} costs {prices[selection]:.2f}")
else:
    print("Invalid selection")
First of all, let's
 * Move the conditional into a function, so we can call it with different selections over and over again
 * Replace the `print` statements with `return` statements, because maybe we want to further process the result
menu = ["Banana", "Peach", 'Potato']
prices = [1.25, 1.75, 1.20]
def select(selection):
    if 0 <= selection < len(menu):
        return f"A {menu[selection].lower()} costs {prices[selection]:.2f}"
    else:
        return "Invalid selection"
So now we can call it and see what it evaluates to
select(2)
In this code, we're managing two separate lists, `menu` and `prices`, and address individual elements by their index. If the kiosk changes its menu, we have to *very carefully* edit both lists to avoid a mess:
menu = ["Banana", "Peach", 'Potato']
prices = [1.25, 1.75, 1.20]
# change the price of a product
prices[2] = 1.80                # what is product number 2???
# remove a product
del(menu[1])
del(prices[1])                  # better use the same index or it'll be a mess
# add a product
menu.append("Water")
prices.append(1.50)
# replace a product
menu[0] = "Gummybears"          # which product did we replace???
prices[0] = 0.95
select(2)
Wouldn't it be convenient if we had some way of clearly associating a product with a price?

This is where *maps* come in. In software engineering, a *map* (which Python calls a "dictionary", we're going to use those terms interchangeably) has nothing to do with geography. A map is a data structure where each key is *mapped* to a corresponding value. Let's store the menu in a dictionary:
menu = {"Banana": 1.25, "Peach": 1.75, 'Potato': 1.20}
len(menu)
Note that `"Banana"` is a *key*, while `1.25` is a *value*.

The dictionary allows us to retrieve values by their key. This is done with a notation similar to accessing list elements via their index, but instead we use a key. For example:
menu["Potato"]
Now we can rewrite and call our selection function like so:
menu = {"Banana": 1.25, "Peach": 1.75, 'Potato': 1.20}
def select(selection):
    #if 0 <= selection < len(menu):
    if selection in menu:
        #return f"A {menu[selection].lower()} costs {prices[selection]:.2f}"
        return f"A {selection.lower()} costs {menu[selection]:.2f}"
    else:
        return "Invalid selection"
select("Banana")
Note that to check whether a *key* exists in a dictionary, you can use the `in` operator. You cannot directly check whether a *value* exists in a dictionary.
"Peach" in menu
And if we want to change the menu, that's now easy. To change a price, we just assign a new value to an existing key:
menu["Banana"] = 6.55       # "Because of inflation!"
select("Banana")
Adding a new product looks exactly the same, just with a new key:
menu["Water"] = 1.50
menu
To remove a product, we just delete the key (the value also gets deleted):
del(menu["Banana"])
menu
A few things to know about dictionaries in Python:
 * key/value pairs in a dictionary do not have any particular ordering (just like values in a set)
 * `{}` is the empty dictionary (you can add elements later)
 * any *key* can only appear once in a dictionary (that's the point), but multiple keys can reference the same *value*
 * the *values* in a dictionary can be of any arbitrary type
 * the *keys*, however, must be **immutable**
things = {}                        # empty dictionary
things[0] = "nil"                  # 0 is the key, not an index
things[0] = "zero"                 # overwrites the value "nil"
things["two"] = 2
things[2] = 2                      # same value can appear multiple times
things["a list"] = [1, 2, 3]       # values can be of mutable types
things[('a', 'tuple', 123)] = 13   # even a tuple can be a key, as long all the contents are immutable

# NOT possible because lists are mutable; they cannot be dictionary keys:
#things[['a', 'list']] = "invalid"

print(things[('a', 'tuple', 123)]) # that tuple really works as a key!
print(things)
You'll often want to only deal with the keys or the values of the dictionary. For this, simply call `.keys()` or `.values()`, respectively. 
menu = {"Banana": 1.25, "Peach": 1.75, 'Potato': 1.20}
menu.keys()
menu.values()
You can more or less ignore that this gives you `dict_keys` and `dict_values`, but you could convert them to lists:
list(menu.keys())
Finally, you may want to get the key/value-pairs as a list of tuples. You can do this using `items()`:
menu.items()
list(menu.items())
<span style="color:purple;font-weight:bold">Exercise</span>

Implement a phonebook. Note the following:
 * The implementation should assume that contacts are stored in a dictionary where keys are the names of people and values are their phone numbers (as strings).
 * Implement a function `add_contact(phonebook, name, number)` which adds a new entry to `phonebook`, but only if `name` is not already in the phonebook. In the latter case, it should print `"Already in phonebook"`
 * Implement a function `delete_contact(phonebook, name)` which removes an entry from `phonebook` and ignores the case where the given name is not in `phonebook`.
 * Implement a function `find_contact(phonebook, name)` which *returns* the number of the given contact. If the contact is not in `phonebook`, it should *print* `"Not found"`.
# exercise solution
my_contacts = {
    "Joe": "+41440002341",
    "Anne": "+41441112341",
}

def add_contact(phonebook, name, number):
    if name in phonebook:
        print("Already in phonebook")
    else:
        phonebook[name] = number
    
def delete_contact(phonebook, name):
    if name not in phonebook:
        print("not in phonebook")
    else:
        del(phonebook[name])
        
def find_contact(phonebook, name):
    if name not in phonebook:
        print("not in phonebook")
    else:
        return phonebook[name]

add_contact(my_contacts, "Bob", "+41449999912")
my_contacts
add_contact(my_contacts, "Alice", "+41440000012")
delete_contact(my_contacts, "Bob")
find_contact(my_contacts, "Alice")
# List comprehensions

Sometimes, you have a collection of values, and you want to do the same thing to each of the values to create a new list. This is where Python uses *list comprehensions*.
names = ["bob", "alice", "tony"]
[name.capitalize() for name in names]
Note that `names` has **not** been changed! The list comprehension creates a *new* list with the transformed values:
capitalized_names = [n.capitalize() for n in names]
print(names)
print(capitalized_names)
A few more examples:
[n*2 for n in range(10, 2, -2)]
[f"{n} squared is {n**2}" for n in range(5)]
<div>
<img src="sum.png" alt="Sum Formula" style="width: 100px;"/>
</div>
sum([i**2 for i in range(3,7)])
When using a list comprehension, you can conveniently filter the input collection by appending an `if` condition at the end, for example:
[f"{n} squared is {n**2}" for n in range(10) if n % 2 == 0]
[character for character in "Hello, World!" if character.isalpha()]
[character for character in "Hello, World!" if character.lower() in "aeiou"]
sum([int(character) for character in "c1h291hgf93e" if character.isdigit()])
This illustrates the general syntax:

<div>
<img src="list_comp.png" width="800"/>
</div>
def cleanup(name):
    return name.strip().capitalize()
def is_string(name):
    return type(name) == str
[cleanup(name) for name in ["   alice  ", 123, False, "bob"] if is_string(name)]
<span style="color:purple;font-weight:bold">Exercise</span>

Write an expression that determines the length of the longest word in a list of words.
# exercise solution
words = "The latter consisted simply of six hydrocoptic marzlevanes".split()

# Dict comprehensions

The exact same concept exists for dictionaries as well. If you have a collection of values and would like to create a new dictionary from them, use a similar syntax. The important thing to understand is that instead of producing *one* value at a time, like for a list comprehensions, you're producing *key*: *value* pairs (`key: value`).
Instead of just creating one number at a time for the resulting list...
[n**2 for n in range(10)]
...this example creates a key: value pair for the resulting dictionary:
{n: n**2 for n in range(10)}
Here's a dictionary where the keys are the characters that appear in a string and the values are how many times that character appears:
sentence = "Hello, world!"
{char: sentence.count(char) for char in set(sentence)}
Again, you can add a filter at the end. Here, we're ignoring vowels:
{char: sentence.count(char) for char in set(sentence) if char not in "aeiou"}
Here's our menu dictionary again:
menu = {"Banana": 1.25, "Peach": 1.75, 'Potato': 1.20}
Let's create a list of all products which start with a "P", using a list comprehension, using only the dictionary keys as input:
[product for product in menu.keys() if product.startswith("P")]
Or, if we want to also keep the prices, then we use a dict comprehension with the same filter:
{product: price for product, price in menu.items() if product.startswith("P")}
Note that we state `for product, price in menu.items()`, meaning each individual element that's being transformed will be a tuple like `("Peach", 1.75)`, which is why we can assign the two tuple values to the local variables product and price. Remember that you can assign multiple values on the left side of an expression, e.g.:
name, age = "Alice", 37
So `for product, price in menu.items()` is essentially the same thing, for each individual key-value pair in `menu.items()`
This illustrates the general syntax:
<div>
<img src="dict_comp.png" width="800"/>
</div>
def cleanup_key(name):
    return name.strip().capitalize()
def number_as_binary(number):
    return bin(number)
def is_integer(value):
    return type(value) == int
{cleanup(name): number_as_binary(number) for name, number in {"bob": 3.5, "alice": 3}.items() if is_integer(number)}
<span style="color:purple;font-weight:bold">Exercise</span>

Write a dict comprehension that takes in a list of words and produces a dictionary mapping words to their length. All keys should be lower-case.
# exercise solution
words = "How much wood would a woodchuck chuck if a woodchuck could chuck wood".split()
# Important Info!

The Info1 Midterm on 04.11.2024 will NOT take place in the previously announced rooms (KO2-F-180, HAH-E-03, and HAH-E-11). Instead, the following rooms (**all at Irchel Campus**) will be used:

 * Y24-G-45
 * Y15-G-19
 * Y15-G-40
 * Y15-G-60

You will be assigned one specific room 1+ week before the exam (everyone will receive an email to their UZH address). For now, just be aware that on 04.11.2024 between 18:00-20:00, you have to **be at Irchel Campus**, not Center Campus.
# Quick recap from last week

### Useful built-in functionality
list(range(10,-10, -3))
[x+100 for x in range(5,10)]
list(enumerate(["Gold", "Silver", "Bronze"], 1))
sum(range(1, 6, 2))
min([6, 3, 9])
max([6, 3, 9])
### `if`, `elif`, `else`
if "x" in "apple":
    print("x is in apple")    # not executed
if True:
    print("First True")
elif True:
    print("Also True, but not executed because the previous condition was already True")
else:
    print("Else")
grades = {"Alice": 5.5, "Bob": 3.5}
def get_or_default(data, key):
    if key not in data:
        return 1.0
    else:
        return data[key]
get_or_default(grades, "Terrance")
### Thruthiness
if ["a", "non-empty", "list"]:
    print("evaluates as True")
if []:
    print("bool([]) evaluates to True")
else:
    print("bool([]) evaluates to False")
bool(1+1)
bool(1-1)
### Dictionary
grades = {"Alice": 5.5, "Bob": 3.5}
grades["Jack"] = 3.75
del(grades["Bob"])
print(grades.keys())
print(grades.values())
print(grades.items())
### List comprehensions
[country[:3].upper() for country in ["Germany", "Switzerland", "Italy", "France"]] 
[f"{name}'s grade is {grade}" for name, grade in grades.items()] 
# a list of tuples, where every tuple contains lat. and long. coordinates and a city name
# CC BY 4.0 https://simplemaps.com/
cities = [
    (35.6839,  139.7744, "Tokyo"),
    (40.6943,  -73.9249, "New York"),
    (19.4333,  -99.1333, "Mexico City"),
    (18.9667,   72.8333, "Mumbai"),
    (-23.5504, -46.6339, "Sao Paulo"),
]
[f"{city} is located at {lat}, {lon}" for lat, lon, city in cities]
# filter for cities in the southern hemisphere
[f"{city} is located at {lat}, {lon}" for lat, lon, city in cities if lat < 0]
### Dict comprehensions
{country[:3].upper(): country for country in ["Germany", "Switzerland", "Italy", "France"]}
grades = {"Alice": 5.5, "Bob": 3.5}
{name: grade >= 4 for name, grade in grades.items()}
# create a dictionary for looking up city coordinates
{city: (lat, lon) for lat, lon, city in cities}
<p style="height:100px"></p>
<hr>
<p style="height:100px"></p>




# Ternary operator

Sometimes you want an expression to have one value if a condition is true and another value if a condition is false. Using `if`/`else` normally, you might write:
temperature = 32
if temperature < 27:
    feeling = "cold"
else:
    feeling = "hot"
feeling
Most languages provide a shorthand *ternary operator* for these situations, and the syntax usually looks something like this:

```isConditionTrue ? 'then this value' : 'otherwise this value'```.

In python, the syntax looks like an `if`/`else` squeezed onto a single line: 
temperature = 32
feeling = "cold" if temperature < 27 else "hot"
feeling
Remember that any part of such an expression could be replaced by another expression, and that you don't necessarily need to assign the result to a variable. More generally, the syntax can be expressed as:

```whenTrueExpression if checkConditionExpression else whenFalseExpression```.

For example:
temperature = 32

def is_cold(temperature):
    print("call 1")
    return temperature < 27
    
def cold_feedback():
    print("call 2")
    return "cold"
    
def hot_feedback():
    print("call 3")
    return "hot"
    
cold_feedback() if is_cold(temperature) else hot_feedback()
The ternary operator is also adds more flexibility when transforming values in a comprehension. For example, here we use a different value depending on the second tuple value:
grades = {"Alice": 5.5, "Bob": 3.5}
{name: "failed" if grade <= 4 else "passed" for name, grade in grades.items()}
Here, we construct a string depending on the first tuple value (which we name `lat` in the comprehension). Note that if you're iterating over tuple values, and you don't need some of them, you can name it `_` by convention:
[f"{city} is located in the {'northern' if lat > 0 else 'southern'} hemisphere" for lat, _, city in cities]
<span style="color:purple;font-weight:bold">Exercise</span>

Write a dict-comprehension that creates a dictionary of student-name to grade, but adds a 0.25 "bonus" to any passing grade (e.g. 4.25 should become 4.50 but 3.75 should remain 3.75)
# exercise solution
grades = {"Alice": 5.5, "Bob": 3.5, "Linda": 6.0}
# write a dict comprehension that produces: {'Alice': 5.75, 'Bob': 3.5, 'Linda': 6.0}

# `NoneType` and `None`

So far, we proclaimed that every function takes zero or more parameters and returns *something*. This is in fact true. Here's our familiar `power2` function:
def power2(x):
    return x ** 2
power2(4)
Just for clarity, let's move the `x ** 2` expression out of the return statement and store it in a variable; then return that variable. This is semantically equivalent:
def power2(x):
    result = x ** 2
    return result
power2(4)
Let's also store the return value from calling the function in a new variable:
four_squared = power2(4)
And then use that variable to construct an f-string which also checks the type of the return value:
f"{four_squared} is of type {type(four_squared)}"
But watch what happens, if we "forget" to return the result:
def power2_no_return(x):
    result = x ** 2          # the result is assigned to the 'result' variable, but never returned

four_squared = power2_no_return(4)
f"{four_squared} is of type {type(four_squared)}"
As you can see, a function that "doesn't return anything", returns the value `None`, which has the type `NoneType`.

`None` is really just a value like any other (say, `"Hello!"`, `False` or `4.6`). But while the `int` type has many possible values (like `3` or `9001`), and the `bool` has two possible values (`True` and `False`), the `NoneType` just has a single possible value: `None`.

**Remember: *every* function in Python returns a value. If nothing else is returned, then that value is `None`.**

The following code is equivalent:
def power2_no_return(x):
    result = x ** 2
    return None
This means that you can return `None` explicitely, if you want. But if a function's body executes without ever returning anything explicitely, the function will eventually return `None` (unless it crashes, of course).

This is also why it's very important to realize that `print` is really nothing like `return`. See the following two functions:
def returning(x):
    return x + 1

def printing(x):
    print(x + 1)
Both of these functions take a number as the only parameter `x`. But one of these functions **returns** the value of `x + 1`, while the other **prints** it. The difference may appear subtle, but it is very significant. See what happens if we store the return values of calling `returning` and `printing`:
result = returning(10)
f"{result} is of type {type(result)}"
result = printing(10)
f"{result} is of type {type(result)}"
As you can see, `returning` returns an integer, which we store as `result`. However, if we do the same by calling `printing`, then the variable result will not contain an integer, but `None` instead.

This can be confusing, because if you just run both examples in Jupyter Notebook, they look *almost* identical:
# snippet 1
def returning(x):
    return x + 1
returning(10)            # this evaluates to: 11, so Jupyter prints it
# snippet 2
def printing(x):
    print(x + 1)        # this prints 11
printing(10)            # this evaluates to: None, so Jupyter doesn't print anything
Looks the same, right? But it isn't:

 * When executing snippet 1, these things happen in order:
   1. `returning` is called with parameter `10`
   2. the function body of `returning` is executed with `x = 10`
   3. `x + 1` is computed, resulting in the value `11`
   4. The value `11` is **returned** from the function; the function is done executing
   5. The final statement of the snippet, `returning(10)`, is done evaluating and Jupyter Notebook prints its value: `11`
 * When executing snippet 2, these things happen in order:
   1. `printing` is called with parameter `10`
   2. the function body of `printing` is executed with `x = 10`
   3. `x + 1` is computed, resulting in the value `11`
   4. The value `11` is **printed** as part of executing the function body
   5. The value `None` is **returned** from the function; the function is done executing
   6. The final statement of the snippet, `printing(10)`, is done evaluating and Jupyter Notebook does not print anything, because this statement evaluated to `None`.
  
It's crucial to understand that in snippet 1, we see the number `11` because Jupyter Notebook evaluates the call `returning(x)`, which results in the value `11`. By contrast, in snippet 2, we see the number `11` because the `printing` function prints it.
We can properly see this, if we print the type of the resulting variables:
print(type(returning(10)))
print(type(printing(10)))
So while it **is** is true that every function returns something, that something can be a special value which indicates nothingness: `None`.

Note that `print` also returns `None`:
type(print("Hello"))
my_contacts = {
    "Joe": "+41440002341",
    "Anne": "+41441112341",
}

def add_contact(phonebook, name, number):
    if name in phonebook:
        print("Already in phonebook")
    else:
        phonebook[name] = number
        
result = add_contact(my_contacts, "Bob", "+41449999912")
print(result)
As you can see, `add_contact` doesn't even contain any `return` statements. It might `print` something, but it always returns `None`. By contrast, `None` can also be used when it makes sense semantically for a function to either return *something* or *nothing*. You also know this example:
def find_contact(phonebook, name):
    if name not in phonebook:
        print("not in phonebook")
    else:
        return phonebook[name]

result = find_contact(my_contacts, "Bob")
print(result)
result = find_contact(my_contacts, "Unicorn")
print(result)
As you can see, `find_contact` returns the number for a contact only if the number is in the phonebook. Otherwise, it returns `None`. This makes sense, because it's a *good* return value if the contact could not be found. It is always better to return `None` in such cases, rather than "magic values" like `"Nothing"`, `"Not found"`, `-1`, `False` or anything like that.
<span style="color:purple;font-weight:bold">Exercise</span>

What will the following snippet print?
def even(x):
    if x % 2 == 1:
        return False

if even(2):
    print("Even")
else:
    print("Odd")
# Early `return`

We've seen that a function always returns a value. Sometimes it makes sense to write code using *early* `return` statements. In the following example, we want to generate a suitable string based on the given temperature:
def feeling(temperature):
    result = "?"
    if temperature < 0:
        result = "freezing"
    elif temperature < 15:
        result = "cold"
    elif temperature < 25:
        result = "mild"
    else:
        result = "hot"
    return result
feeling(23)
We can rewrite this using early `return`s by simply returning the result as soon as it's ready:
def feeling(temperature):
    if temperature < 0:
        return "freezing"
    elif temperature < 15:
        return "cold"
    elif temperature < 25:
        return "mild"
    else:
        return "hot"
feeling(23)
Or even:
def feeling(temperature):
    if temperature < 0:
        return "freezing"
    if temperature < 15:
        return "cold"
    if temperature < 25:
        return "mild"
    return "hot"
feeling(23)
Because once a return statement is reached, the function ends execution and returns the given value. Of course, you can also return `None` at any point, if that makes sense:
my_cities = {
    "Tokyo":       (35.6839,  139.7744),
    "New York":    (40.6943,  -73.9249),
    "Mexico City": (19.4333,  -99.1333),
    "Mumbai":      (18.9667,   72.8333),
    "Sao Paulo":   (-23.5504, -46.6339),
}
def find_city(cities, city):
    if city not in cities:
        return None
    return cities[city]
print(find_city(my_cities, "Mumbai"))
print(find_city(my_cities, "Zurich"))
The following implementation is equivalent, but does not explicitely return `None`. Even though this is the same, the previous version is better, because it's easier to understand.
def find_city(cities, city):
    if city in cities:
        return cities[city]
print(find_city(my_cities, "Mumbai"))
print(find_city(my_cities, "Zurich"))
# `for` loops

Finally, the cat is out of the bag. Python, like many other programming languages, provides `for` loops. Using `for`, we can execute a block of code *for every item in a collection*.
for name in ["Alice", "Bob"]:
    print(f"This is {name}!")
sentence = "Buy into this new audio idea".split()
result = []
for word in sentence:
    result.append(word.capitalize())
print(result)
You may imagine that you could write this as a list comprehension:
sentence = "Buy into this new audio idea".split()
result = [word.capitalize() for word in sentence]
print(result)
So as a rule of thumb:
 * If you're just filtering an existing collection and transforming certain elements for a new collection, use a comprehension
 * If you have more complicated things to do, use a `for` loop.
In the following example, we iterate over a list of words and place the words in three different lists, depending on how many vowels and consonants the words contain:
sentence = "Buy into this new audio idea".split()    # ['Buy', 'into', 'this', 'new', 'audio', 'idea']

more_vowels = []
equal = []
more_consonants = []

for word in sentence:
    vowel_count = sum([1 for character in word if character in "aeiou"])
    cons_count = len(word) - vowel_count
    if vowel_count > cons_count:
        more_vowels.append(word)
    elif cons_count > vowel_count:
        more_consonants.append(word)
    else:
        equal.append(word)
        
print(more_vowels)
print(equal)
print(more_consonants)
You *could* achieve the same result using three comprehensions. You decide which approach is more readable.
more_vowels =     [word for word in sentence if len([char for char in word if char in "aeiou"]) > len(word)/2]
equal =           [word for word in sentence if len([char for char in word if char in "aeiou"]) == len(word)/2]
more_consonants = [word for word in sentence if len([char for char in word if char not in "aeiou"]) > len(word)/2]
print(more_vowels)
print(equal)
print(more_consonants)
Let's have a few more examples for comprehensions and their equivalent `for` loops:
result = [x**2 for x in range(10) if x % 2 == 0]
print(result)
...as...
result = []
for x in range(10):
    if x % 2 == 0:
        result.append(x**2)
print(result)
Or here's an example how a dict comprehension...
result = {x: x**2 for x in range(10) if x % 2 == 0}
print(result)
...could be written as...
result = {}
for x in range(10):
    if x % 2 == 0:
        result[x] = x**2
print(result)
<span style="color:purple;font-weight:bold">Exercise</span>

Here's a classic programming interview question:

Write a function that prints the numbers from 1 to 20, but...
 * if the number is divisible by `3` print `"Fizz"`
 * if the number is divisible by `5` print `"Buzz"`
 * if the number is divisible by both `3` and `5` print `FizzBuzz` 
# exercise solution

### Iterating over different collection types

Let's look at a few more common examples for how `for` loops can be used to iterate over different kinds of collections. You've already seen how to iterate over a list, and of course, iterating over a tuple is basically the same:
names = ("Alice", "Bob", "Bert")
for name in names:
    print(f"{name} starts with {name[0]}")
Iterating over a set is also the same (but remember that there is no way of knowing in which order the elements will be treated):
names = {"Alice", "Bob", "Bert"}
for name in names:
    print(f"{name} starts with {name[0]}")
When iterating over a dictionary, you could...
 * iterate over just the keys (`my_dict.keys()`)
 * iterate over just the values (`my_dict.values()`)
 * iterate over key/value pairs (`my_dict.items()`)
One example for each:
birthdays = {"Alice": "1984-12-24", "Bob": "2001-01-02", "Bert": "1999-12-01"}
for name in birthdays.keys():
    print(f"We know {name}'s birthday")
for day in birthdays.values():
    if not day.startswith("2"):
        print(f"{day} feels like it was yesterday")
for name, day in birthdays.items():
    print(f"{name}'s birthday is {day}")
Remember that `.items()` returns a list of tuples, where each tuple contains a key and its corresponding value:
birthdays.items()
<span style="color:purple;font-weight:bold">Exercise</span>

Write a function `remember` that takes a dictionary `birthdays`, which contains names and birthdays as keys and values. The function should take an additional parameter `month` which should be an integer between 1 and 12. The function should *return* a string like `"Birthdays in MONTH: name1, name2, ..."`, containing the names of all those people who have their birthday in the given month.
# exercise solution
bdays = {"Alice": "1984-12-24", "Bob": "2001-01-02", "Bert": "1999-12-01"}

def remember(birthdays, month):
    pass

remember(bdays, 12)
# `while` loops

A `while` loop is abit like a an `if` condition that repeats until the condition becomes `False`. If the condition is `False` from the start, the `while` body never executes even once (just like an `if` with a `False` condition).
n = 3
while n > 3:
    print(n)
    n = n - 1
The big problem with `while` loops is that they may never end:
# Running this may crash your jupyter notebook:

#n = 3
#while n > 3:
#    print(n)
In general, you **don't** want to use `while` loops.

It does not make sense to replace...
for i in range(3):
    print(i)
with
n = 0
while n < 3:
    print(n)
    n += 1
because you **know** in advance that this loop runs for a fixed number of times (3). The same is true for any collection.


By contrast, imagine you are programming a game, which receives button presses from the game controller, and which displays graphics on the screen, say, 60 times per second. In this case,  you don't know how many frames will be rendered onto the screen in advance. In that case, your code might look something like this:
from random import randrange

player_is_alive = True
while player_is_alive:
    print("Player is stomping goombas and collecting coins")
    player_is_alive = not randrange(5) == 0            # in 1 out of 5 runs, the player will die randomly
**Remember: Only use a `while` loop if you do not know the number of executions in advance**

(Or to keep it very simple: just don't use while loops at all.)
# References

The word *reference* has a very specific meaning in programming, and it's very important to understand. Have a look at this example, where we create a list of numbers and assign it to the variable `l`:
l = [1, 2, 3]
print(l)
What Python does internally is:
 1. Create a list with 3 elements and store it in memory
 2. Create a variable `l` and make it *reference* (i.e.: "point at") the list stored in memory.

<img src="ref_01.png" alt="Drawing" style="width: 150px;"/>

Now what happens if we assign the variable `l` to yet another variable `x`?
x = l
print(l)
print(x)
We can see that printing `l` and `x` both yield the same result. But this is **not** because `x` is a *copy* of `l`. Rather than that, `x` just *points at* the same list as `l` does.

<img src="ref_02.png" alt="Drawing" style="width: 150px;"/>

So what happens if we change one of the elements in `x`?
x[0] = 7
print(l)
print(x)
As you can see, now the element at index 0 has changed for both `x` **and** `l`! This is because both variables **referenced** the same list, so modifying `x` means modifying `l`!

<img src="ref_03.png" alt="Drawing" style="width: 150px;"/> <img src="ref_04.png" alt="Drawing" style="width: 150px;"/> <img src="ref_05.png" alt="Drawing" style="width: 150px;"/> 

Recognize the difference between *creating* an object and *referencing* it. In the examples above, a list object is *created* using `[1, 2, 3]`, and then *referenced* using `l = ...` and `x = ...`. Two *references* refer to the same list *object*.
# Checking for Equality

Now that you know references, you can understand the distinction between `==` and `is`:
 * `==` checks if two things are *equivalent*
 * `is` checks if two things are the exact same thing.
This is best illustrated using an example:
l = [7, 2, 3]
x = l
y = [7, 2, 3]
print(l == x)   # True
print(y == x)   # True
print(l is x)   # True
print(y is x)   # False
<img src="ref_06.png" alt="Drawing" style="width: 320px;"/>

`is` will only be true if the two things being compared *refer to* the exact same object in memory, so it's a very basic comparator. `==` on the other hand depends on the types of values involved:
1.0 == 1
"1" == 1
{1: "one", 2: "two"} == {2: "two", 1: "one"}
This means `==` is implemented individually for any particular type. In a future lecture, you will learn how to make obejcts comparable yourself.

For now, you will likely want to use `==` to make comparisons in most situations. `None` is an exception to this rule: the Python style guide ([PEP8](https://peps.python.org/pep-0008)) recommends using `is` when comparing to `None`. So you should do
l = [1, None, "hello"]
if l[1] is None:
    print("It's None")
and not
l = [1, None, "hello"]
if l[1] == None:
    print("It's None")
This is ultimately a design choice. In general, referencing variables from outside the local scope can lead to more errors.
# Everything's an object (in Python)

By now, you're familiar with the idea that new objects are created in memory in a variety of circumstances, and that one or more references can point to an object:
l = [1, 2, 3]   # a new object of type list is created and assigned to l
x = l           # the object referenced by l is also assigned to x
x is l          # x and l refer to the same object
The truth is, that (in Python) any kind of value is, fundamentally, an **object**. This includes "simple" values such as integers, but also complex things like functions and classes (and not just class instances!). To see why, consider what you can do with your typical object.

An object can, among other things, be...
 1. created
 2. assgined to a variable
 3. stored a collection, like a list or dictionary
 4. passed as a function parameter
 5. returned as a function return value

...as shown here:
l = [1, 2, 3]          # create and assign
x = l                  # assign
x
outer = [l, "hello"]   # store in a collection
print(outer[0][2])
def print_thing(thing):
    print(thing)
print_thing(l)         # pass to a function as a parameter
def pair():
    l = [10, 15]
    return l           # return from a function
print(pair())
What's important is that all the same things are indeed true also for functions...
def power2(x):              # create and "assign" (i.e. name)
    return x ** 2
power2
also_power2 = power2        # assign
print(also_power2(2))       # same as power2(2)
also_power2
l = [also_power2, "hello"]  # store in a collection
print(l[0](3))              # same as power2(3)
def call_with_4(thing):
    res = thing(4)          # same as power2(4)
    print(res)
call_with_4(power2)         # pass to a function as a parameter
def give_power2():
    def y(x):              # create and "assign" (i.e. name)
        return x ** 2
    return y           # return from a function
print(give_power2()(5))       # same as power2(5)
def give_power(y):
    def power(x):
        return x ** y
    return power

power3 = give_power(3)
power3(4)
This is what we call *"Higher-order functions"*, or *"Functions as 1st class citizens"*. It simply means that functions can be treated like any other value
 * functions can be stored in data structures, e.g. in a list
 * functions can be assigned to variables
 * functions can be accepted as parameters
 * functions can be return values
# What you learned today

 * Testing in ACCESS (copy/paste and rename the sample test to add more tests!)
 * Ternary Operator (`int(x) if x.isdigit() else x`)
 * `NoneType` and `None`
 * Early `return`
 * `for` and `while` loops
 * References
 * Equivalence (`==`) and identity (`is`)
 * Everything's an object (and higher-order functions)# Important Info!

## Infrastructure-Test at Messe Oerlikon

If you are an Info1-Student, **you must go to the physical infrastructure test** at Messe Oerlikon on October 28.

More information on the "Functional Test" and required software will follow next week.
# Office hours

* Mon 10-11: many people
* Thu 12-13: almost no people -----> change time and location to Tue 10-11 at Center campus?
* Fri 10-11: few people

**Should the office hours from Thu 12-13 be moved to Center Campus at Tue 10-11?**
# Ensure your edu-ID is linked to your University Account

Log into [https://eduid.uzh.ch](https://eduid.uzh.ch) and ensure that the University of Zurich shows up under "Organizations". If it does not, click "Add organizational identity" and follow the steps.

<img src="eduid.png" alt="Drawing" style="width: 1000px;"/>
## Midterm location: Irchel Campus

The Info1 Midterm on 04.11.2024 will NOT take place in the previously announced rooms (KO2-F-180, HAH-E-03, and HAH-E-11). Instead, the following rooms (**all at Irchel Campus**) will be used:

 * Y24-G-45
 * Y15-G-19
 * Y15-G-40
 * Y15-G-60

You will be assigned one specific room 1+ week before the exam (everyone will receive an email to their UZH address). For now, just be aware that on 04.11.2024 between 18:00-20:00, you have to **be at Irchel Campus**, not Center Campus.
# Quick recap from last week

### Ternary conditional operator
x = -5
x_abs = x if x >= 0 else -x
print(x_abs)
# FYI, Python ships with an abs() function:
print(abs(x))
grades = {"Alice": 5.5, "Bob": 3.5, "Linda": 6.0}
{name: grade + 0.25 if 4 <= grade <= 5.75 else grade for name, grade in grades.items()}
### `None` and `NoneType`
print(type(123))
print(type(True))
print(type(None))
Functions in Python implicitly return `None` unless they explicitely return something else
def printing(x):
    print(x + 1)        # this prints 11; the function eventually returns None after that
printing(10)            # this evaluates to: None, so Jupyter doesn't print anything
The `print` function returns `None`
def x():
    res = print("Hello")
    return res
result = x()
print(result)
print(type(result))
Be careful if you're dealing with values which could be *Falsy* or `None`. When used in a conditional expression, both will result in `None`:
None == False
bool(None) == bool(False)
if not None:
    print("None is falsy")
if not False:
    print("False is falsy")
def is_negative(x):
    if x < 0:
        return True
    if x > 0:
        return False

if is_negative(0):
    print("0 is negative")
else:
    print("0 is positive") # but by most definitions, zero is neither positive nor negative
### Early return
my_cities = {
    "New York":    (40.6943,  -73.9249),
    "Mumbai":      (18.9667,   72.8333),
}
def find_city(cities, city):
    if city not in cities:
        return None            # function ends execution here if city was not in cities
    return cities[city]        # this line is only reached if city IS in cities
print(find_city(my_cities, "Mumbai"))
print(find_city(my_cities, "Zurich"))
### `for` loops
for x in range(3):
    print(x)
my_cities = {
    "New York":    (40.6943,  -73.9249),
    "Mumbai":      (18.9667,   72.8333),
}
# note that city is a string and coordinates is a tuple with 2 elements, because items() returns key/value pairs.
for city, coordinates in my_cities.items():
    print(f"{city} is located at {coordinates[0]}, {coordinates[1]}")
### `while` loops
from random import uniform
from time import sleep
    
# This just returns a random value. In a real scenario this would look up the rate on the internet.
def get_latest_rate():
    return uniform(1.16, 1.21)

# FYI, here's how you might actually check the real exchange rate:
def real_get_latest_rate():
    import requests
    response = requests.get("https://api.exchangerate-api.com/v4/latest/CHF") # JSON document containing exchange rates
    if response.status_code == 200:
        return response.json()['rates']['USD']
    else:
        raise Exception("Failed to retrieve data")


desired_rate = 1.20
latest_rate = get_latest_rate()
while desired_rate > latest_rate:
    print(f"Latest rate is {latest_rate:.3f}; not high enough. Will check again in 500ms...")
    sleep(0.5)
    latest_rate = get_latest_rate()
print(f"Latest rate is {latest_rate:.3f}; Buy now!")
**Important**: Use `while` loops **only if the number of effective iterations is unknown**. Use `for` loops to iterate over collections!
### References
l = [1, 2, 3]
x = l
<img src="ref_02.png" alt="Drawing" style="width: 150px;"/>
x[0] = 7
print(l)
print(x)
<img src="ref_03.png" alt="Drawing" style="width: 150px;"/> <img src="ref_04.png" alt="Drawing" style="width: 150px;"/> <img src="ref_05.png" alt="Drawing" style="width: 150px;"/> 
### Checking for Equality

 * `==` checks if the two sides are *equivalent*
 * `is` checks if the two sides are the exact same thing (i.e., the same object in memory).
l = [7, 2, 3]
x = l
y = [7, 2, 3]
print(l == x)   # True
print(y == x)   # True as well, because the lists referred to by l and y both contain the exact same elements
print(l is x)   # True, because l and x refer to the exact same object in memory
print(y is x)   # False, because y and x are two different objects in memory
<img src="ref_06.png" alt="Drawing" style="width: 320px;"/>

<p style="height:100px"></p>
<hr>
<p style="height:100px"></p>




# Pass-by-reference

Python function calls use "pass-by-reference". This means that if a function is called with a reference (i.e., a variable), then only that reference is passed into the function. The value referenced is *not* copied (that would be called "pass-by-value").

In the following example we
 * declare a function `foo` which takes one parameter ("a list" `l`) and appends a value to it
 * create a list containing three elements
 * create a variable `x` referencing that list
 * call the function `foo` with `x` as the parameter. `x` is a reference to the list we created. The function receives this reference and appends an element to the referenced list. The function does not return anything. It just edited `l`. Because `l` references the same list as `x`, `x` appears to have been modified as well.

We also print whatever `x` refers to before and after calling `foo`.
def foo(l):
    l.append(4)

x = [1, 2, 3]
print(x)
foo(x)
print(x)
Things to keep in mind:

 * A variable is a **reference** to something in memory.
 * A variable is not the same thing as its value.
 * Multiple variables can reference the same thing in memory.
 * When passing a variable to a function, it's only the reference that is place into the function. Values are not copied.
<img src="ref_07.png" alt="Drawing" style="width: 350px;"/>
So semantically, the following would result in the exact same outcome:
x = [1, 2, 3]
def foo():
    x.append(4)
print(x)
foo()
print(x)
In this example, `foo` does not actually take any arguments. Instead, we reference `x` directly, rather than taking the detour of using `l`. However, this also means that our `foo` function only works for this one specific `x`.
<span style="color:purple;font-weight:bold">Exercise</span>

What would the following snippet print?
x = [1, 2, 3]
y = [4, x, 5]
x.append(y)
def prepend(head, l):
    l.insert(0, head)
    return l
#print(prepend(y, x)[0][1][2])
[https://pythontutor.com/](https://pythontutor.com/)

This brings us to the next topic...
# Scope

Scope determines where in a program a given variable or function can be accessed and modified.

For example, `x` is *in scope* both inside and outside of the `foo` function, because `x` is defined in the *module scope*:
x = [1, 2, 3]     # x is in the module scope
def foo():
    x.append(4)   # we can do things with x inside the function, because x lives in a higher-up / outer-more scope
foo()
print(x)
In other words, inner-more scopes (such as the `foo()` function scope) can **access** variables defined in outer-more scopes (such as the module scope).

However, and this is the most important thing to realize about scope in Python, everytime we use an **assignment** operation, such as `=`, `+=`, `*=` or any other functionality that **assigns** or **re-assigns** a **variable**, then a **new variable** is created **in the local scope**. For example:
m = 10
def reassign():         # Doesn't actually reassign anything
    m = 20              # Variable m is newly created in the local function scope and assigned 20. Global m is not changed.
reassign()
print(m)                # Global m unmodified
And if you try to use other assignment operations (like `-=`, `+=`, `*=`, ...), you will get an exception that the variable you're trying to reassign doesn't even exist in scope:
m = 10
def add_20():
    m += 20             # In scope, m does not exist, so reassigning it is not possible!
#add_20()
That's because `add_20` is the same as:
m = 10
def add_20():
    m = m + 20         # Python will FIRST create the local variable m; then it will evaluate the right side, but this m doesn't have a value yet!
#add_20()
Note that using the `=` operator by itself is *not* the point. For example, you can reassign list or dict elements using `=`. This has nothing to do with variable assignment:
l = [1, 2, 3]
def reassign_list_element():
    l[1] = 2000                # assignment is NOT creating a new variable, it's just modifying a value
reassign_list_element()
print(l)
The same scoping rules apply for function parameters, whose scope is limited to the inside of the function. Here's our familiar `power2` function, which takes a single parameter, `n`. When calling this function, for example `power2(4)`, then the variable `n` inside the function is assigned the value `4`:
def power2(n):
    return n ** 2
power2(4)
However, outside the function, `n` is undefined:
def power2(n):
    return n ** 2
power2(4)
#print(n)           # impossible, because y is not defined in the module scope!
### Shadowing

In the following example, the declaration of `y` as a parameter inside `power2` **shadows** the definition of `y` in the module scope. The `y` inside the function is **not** the same as the `y` outside the function.
y = 10
def power2(y):        # Function parameter y is a NEW variable, and has nothing to do with the module-scope y
    return y ** 2
power2(4)
 This can be illustrated easily by printing the variable in multiple places:
y = 10
def power2(y):
    print(y)        # second print output: value of y which is passed to the function, has nothing to do with the y on line 1
    return y ** 2
print(y)            # first print output: value of y defined on line 1
power2(4)
Even reassigning `y` within the function has no effect on the `y` outside the function!
y = 10
def power2(y):
    y = 6           # reassigning y just overwrites the y passed to the function on line 2!
    print(y)        # value of y which was assigned on line 3
    return y ** 2
print(y)            # still the value of y defined on line 1, reassignment inside power2 had no impact on this!
print(power2(4))
print(y)
print(power2(4))
This is true even if the variable being assigned was not passed as a parameter!

**Again**: any **assignment** you make inside the function will create a new variable within the function scope, even if *a* variable with the same name exists before the assignment!
y = 10
def power2():
    y = 6           # this does NOT reassign the y from line 1, but creates a new y inside the function scope!
    print(y)        # value of y which was assigned on line 3
    return y ** 2
print(y)            # still the value of y defined on line 1, reassignment inside power2 had no impact on this!
print(power2())
print(y)            # y is STILL 10, despite y = 6 inside the function!
print(power2())
It's best to avoid this kind of thing from happening altogether: if you're already using a variable name in a higher-level scope (for example the module scope), then use different variable names for parameters or variables in general in lower-level scopes:
y = 10
def power2(num):        # avoid shadowing by giving this variable a name that does not shadow anything from the higher-level scope
    return num ** 2
print(y)
print(power2(4))
A new scope is created for any
 * Module (i.e. a new file/script)
 * Function (i.e. anything declared using `def` or `lambda`)
 * Class (i.e. anything declared using `class`)
 * Comprehension

However, the following do *not* create a new scope:
 * `if`/`elif`/`else` blocks
 * `for` and `while` loops
if True:
    x = 10
print(x)       # x is in scope, because if statements do not create a new scope
def foo():
    x = 20     # this x defined here does NOT overwrite the x from the module scope! It's a different x.
foo()
print(x)
### Modifying module-scope variables vs. using function parameters

So far, in most examples of functions, we assumed that the function receives **everything** it needs as parameters. This is also true for most exercises on ACCESS. For example, we pass to `find_city` both the dictionary to be searched as the parameter `cities` and the name of the city as parameter `city`:

```
def find_city(cities, city):
```

And then we call the function passing values for both parameters:

```
find_city(my_cities, "Mumbai")
```
such that inside the function `cities` *refers to* the dictionary assigned to `my_cities`
my_cities = {
    "Tokyo":       (35.6839,  139.7744),
    "New York":    (40.6943,  -73.9249),
    "Mexico City": (19.4333,  -99.1333),
    "Mumbai":      (18.9667,   72.8333),
    "Sao Paulo":   (-23.5504, -46.6339),
}
def find_city(cities, city):
    if city not in cities:
        return None
    return cities[city]
print(find_city(my_cities, "Mumbai"))
print(find_city(my_cities, "Zurich"))
But if we wanted to, we could rewrite this function to simply reference the module-scope variable `my_cities`:
my_cities = {
    "Tokyo":       (35.6839,  139.7744),
    "New York":    (40.6943,  -73.9249),
    "Mexico City": (19.4333,  -99.1333),
    "Mumbai":      (18.9667,   72.8333),
    "Sao Paulo":   (-23.5504, -46.6339),
}
def find_city(city):
    if city not in my_cities:
        return None
    return my_cities[city]
print(find_city("Mumbai"))
print(find_city("Zurich"))
This was true for the comprehension task on ACCESS, where each comprehension used the `words` variable already defined on the global scope:
words = ["apple", "mountain", "river", "asteroid", "armadillo", "guitar",
         "sapphire", "keyboard", "planet", "mango", "mirror", "jazz", "robot",
         "lighthouse", "pineapple", "wizard", "cloud", "penguin", "spaghetti"]

# WORSE: functions accesses module-scope variable words
def words_containing_string(s):                               
    return [word for word in words if s in word.lower()]

def words_starting_with_character(c):
    return [word for word in words if word.startswith(c)]

words_starting_with_character("p")
Generally, it would have been better to pass along the words as an additional parameter to each function, like so:
my_words = ["apple", "mountain", "river", "asteroid", "armadillo", "guitar",
         "sapphire", "keyboard", "planet", "mango", "mirror", "jazz", "robot",
         "lighthouse", "pineapple", "wizard", "cloud", "penguin", "spaghetti"]

# BETTER: function only accesses variables local to its own scope
def words_containing_string(words, s):                         
    return [word for word in words if s in word.lower()]

def words_starting_with_character(words, c):
    return [word for word in words if word.startswith(c)]

words_starting_with_character(my_words, "p")
Note that for some ACCESS exercises, you are forced to use the "worse" way.

In general, you can avoid bugs and confusion by always providing functions with all they need, instead of accessing module-scope variables.
### `global`

Remember that any *assignment* inside a function will create a new local variable, even if a variable with the same name exists in a higher-level scope. There is a way of making a function-scope variable be the same as a variable from a higher scope:
y = 10
def dont_do_this():
    global y           # this pulls the higher-level 'y' into the function scope
    y += 1              # now, (re-)assigning y actually changes y in the module scope
print(y)
dont_do_this()
print(y)
However: **don't do this**. There are some fringe reasons where it makes sense to do this, but it's practically **never** necessary and is generally considered a very bad code smell.

Bottom line: **never use the `global` keyword**

Sidenote: if you wanted to make a modification to `y` using a function, the correct way would be:
y = 10
def do_this(num):
    return num + 1        # function doesn't mess with global variables
print(y)
y = do_this(y)            # pass y into the function and use the return value to reassign y
print(y)
# Classes and objects

You can imagine that lists, tuples, sets and dictionaries can be used to represent a wide variety of real-world data. Let's say, for example, that we're writing a vector drawing program (like Adobe Illustrator or Inkscape).

<img src="shapes.png" alt="Drawing" style="width: 400px;"/>

### A vector graphics drawing program

Our program should be able to render various shapes on the screen. For this purpose, it will certainly need to have some internal representation for these shapes. Of course, some shapes can be defined in more than one way, but let's say we settle on these defining features for three of the most basic shapes:

 * Square: side length
 * Rectangle: width and height
 * Circle: radius

We can use dictionaries and functions to store and transform these shapes. Say we store a dictionary with appropriate properties to describe any instance of each shape:
s1 = {"type": "square", "side": 15}
s2 = {"type": "square", "side": 10}
r1 = {"type": "rectangle", "height": 5, "width": 100}
c1 = {"type": "circle", "radius": 2}
shapes = [s1, s2, r1, c1]                # Each shape is stored as a dictionary
print(shapes)
And we could write functions to calculate the `area` of any shape:
import math
def area(it):
    if it["type"] == "square":
        return it["side"]**2
    if it["type"] == "rectangle":
        return it["height"] * it["width"]
    if it["type"] == "circle":
        return math.pi * it["radius"] ** 2
[area(shape) for shape in shapes]
This *works*, but there are a couple of potential issues with this approach:
 * Creating new objects is a bit tedious: we have to spell out dictionary keys and values (...`"type": "rectangle"`...) a lot. Lot's of room for errors!
 * Working on these objects is also tedious: again we have to spell out the dictionary keys: (...`it["type"] == "rectangle"`...)
 * The `area` function is split apart by `if` conditions.

It all seems rather brittle. Because this kind of scenario is extremely common in real-world programming, most programming languages have mechanisms for structuring and abstracting it. Python (like many other languages) supports *classes*.

For now, let's ignore the other shapes and just look at **Circle**:
c1  = {"type": "circle", "radius": 25}       # a specific circle, crudely represented using a dictionary
def area(it):                                # a function that takes a dictionary (which hopefully has the right keys to be a circle)
    if it["type"] == "circle":               # if the dictionary appears to be a circle
        return math.pi * it["radius"] ** 2   # calculate and return its area
### Introducing `class`

Instead of using `"type"` and `"radius"` keys in some arbitrary dictionary, we can define a `class` that describes what circles are like and what can be done with them.

A class defines the **attributes** and **behavior** of a thing. For our circle:
class Circle:                              # NOT a specific circle! Just a description of what a circle is and does
    def __init__(self, radius):            # __init__ is called when a new Circle is created
        self.radius = radius               # we store radius as an attribute of a newly created Circle
    def area(self):                        # now instead of taking a dictionary "it", the function just takes a Circle object "self"
        return math.pi * self.radius ** 2  # we compute and return the area just like before, but reading self.radius instead of it["radius"]
Now we have a class `Circle` (note that class names are written using `CamelCase` by convention), with two functions:
 * `__init__` determines what happens when we want to create a new circle
 * `area` calculates the area like the old function previously did

When functions are part of a class, we usually call them *methods* instead of *functions*.

Now instead of
c1  = {"type": "circle", "radius": 2}
type(c1)
we will do
c1 = Circle(2)
The number `2` we pass along is received by the special `__init__` function.

It's obvious that the type is a `Circle` because that's the point of having classes. In fact, Python will happily tell us its type, while before, the type would have been `dict`:
type(c1)
And instead of calculating the area of a circle like this:
c1  = {"type": "circle", "radius": 2}
area(c1)
we can do this:
c1 = Circle(2)
Circle.area(c1)    # call the area method of the Circle class, and provide the 'c1' circle object as the parameter
Notice how the old function...
def area(it): # it is the circle (as a dictionary object)
    if it["type"] == "circle":
        return math.pi * it["radius"] ** 2
...took an object `it` (which at that point was just a simple dictionary representing a circle) and changed the value for the `radius` key.

The new method...
    def area(self): # self is the circle (as a Circle object)
        return math.pi * self.radius ** 2 
does exactly the same. Just like `it` previously, `self` is the actual circle that we're calculating the area for.

However, this is such a common thing to do, that Python provides the dot-notation syntax for accessing class methods given an object:
# Instead of calling the Circle.area method and provide the 'c1' object as a parameter ... 
Circle.area(c1)    # circle object 'c1' passed as parameter
# ... you can simply call the area method directly on the 'c1' Circle object:
c1.area()          # no parameter passed, because 'self' is clearly the object 'c1'
You already saw this kind of notation when manipulating strings, for example:
s = "Hello"
s.lower()
And indeed, just like you could call `Circle.area` method and give it a circle object (`c1`), you can also call the `str.lower` method and give it a string object (`s`):
s = "Hello"
str.lower(s)           # 'str' is the class for strings, just like 'Circle' is the class for circles
To be clear, there is no need to call `Circle.area(c1)`, because the dot-notation for object will always fill in `self`, the first parameter, with the object that you're calling the method on.

Instead of `Circle.area(c1)` you will always do `c1.area()`, which is the same thing, just like you would do `"Hello".lower()` instead of `str.lower("Hello")`.
Inside the `area` method, instead of specifying a dictionary key `it["radius"]`, we refer to the objects radius via the  `self.radius` attribute. Remember, we createad that attribute when the object was created using `__init__`. Here's the whole class again:
class Circle:
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return math.pi * self.radius ** 2
c1 = Circle(2)              # c1.radius is set by __init__ (where self refers to the same object as c1)
print(c1.area())            # area calculated based on c1.radius in area (where self refers to the same object as c1)

x = "hello"
print(x.upper())            # class str: ... def upper(self): ...
### `print`ing objects

One thing you'll notice rather quickly is that printing your proud creation will not be particularily insightful:
print(c1)
You have to gift your classes a nice string representation yourself. You do this by implementing the `__str__` and `__repr__` methods, both of which must return a string:
 * "`__str__` is for customers". It should return a pretty representation of the object
 * "`__repr__` is for developers". It should return an unambiguous representation (ideally one that could be used to recreate the object)

For our simple `Circle`, this should suffice:
class Circle:
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return math.pi * self.radius ** 2
    def __str__(self):
        return f"A circle with radius {self.radius}"
    def __repr__(self):
        return f"Circle({self.radius})"
c1 = Circle(25)
print(c1)
repr(c1)
You'll notice that when you `print` an object, the `__str__` method will be used. However, when you print some other data structure that just refers to your object, then the `__repr__` method will be used. This is easily illustrated if we put some `Circle`s in a list and then print the **list**:
my_circles = [c1, Circle(70), Circle(1)]
print(my_circles[1])    # __str__ is called to print the single instance at index 1 
print(my_circles)       # __repr__ is called for each instance in the list
The existing method `area` reads properties of a given shape and returns a value. Naturally, doing this doesn't change the object. But just like we can modify collections like lists and dictionaries, we can also modify our custom objects.

Let's implement another method for our `Circle` class which will be able to change the size of the circle. But before that, let's remember how we would have done it in the past, using just dictionaries and plain functions:
c1  = {"type": "circle", "radius": 25}       # a specific circle, crudely represented using a dictionary
def scale(it, factor):                       # a function that takes a dictionary (which hopefully has the right keys to be a circle) and a factor
    if it["type"] == "circle":               # if the dictionary appears to be a circle
        it["radius"] *= factor               # modify the dictionary
scale(c1, 3)
c1
In contrast to the `area` function, which does not take any additional parameters beyond `it`, the `scale` function takes one additional parameter `factor`. Likewise, our `Circle` method will take an additional parameter beyond `self`:
class Circle:                       # NOT a specific circle! Just a description of what a circle is and does
    def __init__(self, radius):     # __init__ is called when a new Circle is created
        self.radius = radius        # we store radius as an attribute of a newly created Circle
    def scale(self, factor):        # now the function just takes "self" instead of "it", and it's a Circle object, rather than just a dictionary
        self.radius *= factor       # we modify the Circle objects radius, just like before

    # the other methods
    def area(self):
        return math.pi * self.radius ** 2
    def __str__(self):
        return f"A circle with radius {self.radius}"
    def __repr__(self):
        return f"Circle({self.radius})"
Now instead of scaling a circle like this:
c1  = {"type": "circle", "radius": 25}
print(c1["radius"])
scale(c1, 3)
print(c1["radius"])
we can do this:
c1 = Circle(25)
print(c1.radius)
c1.scale(3)
print(c1.radius)
<span style="color:purple;font-weight:bold">Exercise</span>

Fully implement `Square` and `Rect` classes, both with appropriate `area` and `scale` functions.

Note that the style guide recommends leaving a blank line between methods (makes it much easier to read):
class Circle:
    def __init__(self, radius):
        self.radius = radius
        
    def area(self):
        return math.pi * self.radius ** 2
        
    def scale(self, factor):
        self.radius *= factor
        
    def __str__(self):
        return f"A circle with radius {self.radius}"
        
    def __repr__(self):
        return f"Circle({self.radius})"

class Square:
    pass

class Rect:
    pass

# when you've implemented all three, this should work:
def do():
    shapes = [Square(10), Square(5), Rect(5, 100), Circle(25)]
    print([shape.area() for shape in shapes])
    print([type(shape) for shape in shapes])
    for shape in shapes:
        shape.scale(3)
    print(shapes)            # uses __repr__
    for shape in shapes:
        print(shape)         # uses __str__

# uncomment to try:
#do()
# Where can I get more exercises?

Besides ACCESS and the old exams in the "Materials" folder on OLAT, one of the best exercises is to re-implement functionality from the Python standard library yourself. Just pick some documentation, for example [String methods](https://docs.python.org/3/library/stdtypes.html#string-methods) or [Math functions](https://docs.python.org/3/library/math.html#number-theoretic-and-representation-functions), and then

 1) Pick a function
 2) Understand how it works by reading the documentation and trying it out
 3) Come up with all possible conditions how the functionality may be used
 4) Implement a function that replicates the exact behavior
 5) Test if it works the same as the original

For example...

 1) let's take the the [.title()](https://docs.python.org/3/library/stdtypes.html#str.title) function
 2) To understand how it works, you can read the documentation...

<div>
<img src="title.png" width="800"/>
</div>

 ... and try out what it does, for example:
'Hello world'.title()
"they're bill's friends from the UK".title()
"WHAT     happens now?".title()
 3) Try to think of each set of conditions in which `title()` might be used:
examples = [
    "",                  # empty string
    "lower case",        # some lower case sentence
    "lower UPPER",       # all-lower and all-upper case words
    "this     sentence contains subsequent spaces, tabs, \tand some ÑÑƒÐ¿ÐµÑ€ ã‚¹ãƒšã‚·ãƒ£ãƒ« characters!",
]
[e.title() for e in examples] # see what .title() does for each example
4) Implement a possible solution:
def my_title(s):
    res = ""
    prev = None
    for char in s:
        if prev is None:
            res += char.upper()
        else:
            if prev == " ":
                res += char.upper()
            else:
                res += char.lower()
        prev = char
    return res

my_title("lower case")
5) Test if it works as expected:
[my_title(e) == e.title() for e in examples]
As you can see, the possible implementation doesn't work correctly for every example yet. Go ahead and practice your skills by writing an implementation that works correctly!

for f in my_title, str.title:
    print(f(examples[-1]))

Re-implementing Python functionality as an exercise has several benefits:

 * You learn about built-in Python functionality so you can use it later
 * You learn how to read documentation (which is also an important skill)
 * You practice coming up with edge-cases and how to test your own code# Important Info!

## Infrastructure-Test at Messe Oerlikon

If you are an Info1-Student, **you must go to the physical infrastructure test** at Messe Oerlikon on October 28.

## Functional Test?

For Info1 specifically, a simple functional test will be released by next week. You will receive an email. Until then, nothing to do here.

## ACCESS

 * Be aware that after each deadline, sample solutions are automatically released on ACCESS in the `solution` folder of each task. There are many ways to solve each task, so our solutions are just a suggestion.
 * You can continue using the "Submit" feature even after the deadline, but any additional points achieved will not be counted.
# Quick recap
## Pass by reference

Variables are just references. Passing a variable `y` into a function as parameter `l` just makes `l` reference **the same object** as `y`.
x = {"Betty": 33, "John": 28}
y = [1, x, 3]
def foo(l):              # l    references the same list object as y
    l[1]["Derek"] = 30   # l[1] references the same dictionary object as x
print(x)
foo(y)
print(x)
## Scope

Any assignment operation (`naked_variable_name_here = ...`) creates a new variable in the **local** scope. This can *shadow* variables of the higher-level scope.

Recommendations:
 * Avoid shadowing by using parameter names that do not overlap with variables of a higher scope.
 * Do not access variables from higher scopes inside functions; instead, provide functions with everything they need as parameters.
y = 10
def power2(y):
    y = 6           # reassigning y just overwrites the y passed to the function on line 2!
    print(y)        # value of y which was assigned on line 3
    return y ** 2
print(y)            # still the value of y defined on line 1, reassignment inside power2 had no impact on this!
print(power2(4))
print(y)
print(power2(4))
## Classes
A class defines the *attributes* and *behavior* of a thing. It is a descriptive *blueprint* for creating *concrete* objects. For example, a `class Circle`, like a blueprint, describes what circles are and what can be done with them, allowing us to create various different concrete circles `c1 = Circle(3)` or `c2 = Circle(100)`.
import math

class Circle:                                 # NOT a specific circle! Just a description of what a circle is and does
    def __init__(self, radius):               # __init__ is called when a new Circle is created
        self.radius = radius                  # the 'self' parameter in __init__ is a "blank sheet of paper", we add a .radius attribute to it
        
    def area(self):                           # self refers to the circle object being worked on
        return math.pi * self.radius ** 2     # for any specific circle (self), the radius is pi*r^2
    
    def scale(self, factor):        
        self.radius *= factor                 # scaling a specific circle (self) means multiplying its radius by a given factor
    
    def __str__(self):                                    # str is for customers
        return f"A circle with radius {self.radius}"
    
    def __repr__(self):                                   # repr is for developers
        return f"Circle({self.radius})"

# use the class blueprint to create and work with concrete Circle objects:
c1 = Circle(10)
print(c1.radius)      # Side note; of course you can access object attributes just like you can call object methods
print(c1.area())
c1.scale(3)
print(c1.radius)
print(c1.area())
<span style="color:purple;font-weight:bold">Exercise</span>

Implement a system to track Todo items.
 * The system will require two classes, one to represent each Todo item, the other to represent a Todo list.
 * Each todo item has a name and a 'done' status (true or false)
 * It should be possible to add todo items to the todo list
 * It should be possible to retrieve not-done and done todo items from the todo list
# Blueprint for a single Todo item
class Todo:
    pass

# Blueprint for a Todo list
class TodoList:
    pass

def do():
    # Concrete Todo list:
    my_todos = TodoList()
    my_todos.add(Todo("Go shopping"))
    my_todos.add(Todo("Do exercises"))
    my_todos.add(Todo("Relax"))
    print(my_todos.get_not_done())
    for t in my_todos.get_not_done():
        from random import choice
        t.done = choice([True, False])  # 50% chance that each todo item gets done
    print(my_todos.get_not_done())
    print(my_todos.get_done())
#do()
<p style="height:100px"></p>
<hr>
<p style="height:100px"></p>




# Positional vs. keyword arguments

There are several ways function arguments are specified in Python. What you've come to know and love are **positional** arguments (like `x` and `n` in the following example):
def power(x, n):
    return x**n
print(power(3,2))
But Python also supports what it calls **keyword** arguments. Keyword arguments specify a default value, and must always come **after** positional arguments:
def power(x, n=2):
    return x**n
print(power(3))      # n is not passed, the default value for n (2) is used
print(power(3, 3))   # n is passed, it is used instead of the default
Of course, you can also used this in methods:
class Person:
    def __init__(self, name, age=0):
        self.name = name
        self.age = age
        
    def __str__(self):
        return f"{self.name} is {self.age} years old"

jim  = Person("Jim")
jack = Person("Jack", 47)
print(jim)
print(jack)
**Watch out!** A tricky situation will arise if you use a *mutable* value as a default parameter! The reason is that whatever you put into your signature as a default parameter is only **instantiated once** when the function signature is executed.

Say you want some parameter to be an empty list by default:
class Student:
    def __init__(self, name, subjects=[]): # this seems intuitive...
        self.name = name
        self.subjects = subjects
        
    def enroll(self, subject):
        self.subjects.append(subject)

bob = Student("Bob")     # not passing a value for 'subjects' so the default ([]) is used
print(bob.subjects)      # [] because that's the default and we haven't added any subjects yet
bob.enroll("Info1")      # enroll bob in Info1
print(bob.subjects)      # ['Info1'] because we've just added it
This appears to work fine, but watch what happens when we now create another instance of `Stundent`:
alice = Student("Alice")   # again, not passing a value for subjects
print(alice.subjects)      # ['Info1'] !!! wtf!?
alice.enroll("Bio3")       # enroll ALICE in Bio3
print(bob.subjects)        # BOB is now enrolled in Bio3 
`alice` and `bob` appear to share the same list for `subjects`! This is because the method signature

```python
def __init__(self, name, subjects=[]):
```

is only executed once when Python interprets the class definition. This makes `subjects` **reference** a new empty list. Later, any `Student` instance created using this constructor will refer to **the same** list object:

```python
def __init__(self, name, subjects=[]):
    self.name = name
    self.subjects = subjects           # self.subjects references the same object as the parameter subjects, which is the list object
```

So it's important that you only use *immutable* values for defaults. If you want to have an empty list by default, you would need to work around this, for example using `None`:
class Student:
    def __init__(self, name, subjects=None):                    # this is the correct way!
        self.subjects = [] if subjects is None else subjects    # this creates a new list [] each time this method is called and subjects is None
        self.name = name
    def enroll(self, subject):
        self.subjects.append(subject)

bob = Student("Bob")  # self.subjects will reference a new list [] every time __init__ is called
print(bob.subjects)
bob.enroll("Info1")
print(bob.subjects)
alice = Student("Alice")
print(alice.subjects)
# Raising exceptions

You will no doubt have already met exceptions when running your code. For example, trying to access a non-existing list index will raise an `IndexError`:
l = [1, 2, 3]
#l[5]    #IndexError
When writing code, you as a developer can cause exceptions intentionally. This makes sense in cases where a reasonable action is impossible. For example, consider the following function:
def age_appropriate_greeting(name, age):
    if age < 18:
        return f"Hoi {name}"
    if age < 65:
        return f"GrÃ¼ezi {name}"
    return f"GRÃœESSECH {name.upper()}!!!"

age_appropriate_greeting("Maria", 77)
What should happen if we supply a negative age? We could...
 * Return some error string like `"Invalid age"`, but that would be intransparent and confusing, because the code would still work.
 * Return `None`. Maybe a bit better, but still not a greeting.

In either case, we're not really communicating that the function was used wrongly. Given that a negative age is truely an exceptional problem, we could decide to `raise` an exception. How about raising a `ValueError`?
def age_appropriate_greeting(name, age):
    if age < 0:
        raise ValueError("negative age")
    if age < 18:
        return f"Hoi {name}"
    if age < 65:
        return f"GrÃ¼ezi {name}"
    return f"GRÃœESSECH {name}"

#age_appropriate_greeting("Maria", -3) ValueError: negative age
This prevents someone from accidentally using the `age_appropriate_greeting` function with invalid parameters and not noticing the issue. With the added exception, invalid use will be prevented. If a developer now uses this function with an invalid age, they will have to fix their code.

We will learn more about exceptions later. For now, just now that you can `raise SomeExceptionType("with a message here")` to crash the program intentionally if invalid things are about to happen. In the exercises, you will be asked to raise [existing Exceptions](https://docs.python.org/3/library/exceptions.html#Exception).
# Inheritance: classes share similarities

We augment our geometric shape example as follows:
 * Each shape (circles, rectangles, squares) also has `x` and `y` coordinates, as well as a color, which should be "black" by default.
from math import pi

class Circle:
    def __init__(self, x, y, radius, color="black"):
        self.x = x
        self.y = y
        self.color = color
        self.radius = radius

    def area(self):
        return pi * self.radius**2

    def __str__(self):
        return f"A {self.color} Circle at {self.x}/{self.y} with radius {self.radius}"

class Rectangle:
    def __init__(self, x, y, width, height, color="black"):
        self.x = x
        self.y = y
        self.color = color
        self.width = width
        self.height = height
        
    def area(self):
        return self.width*self.height

    def __str__(self):
        return f"A {self.color} Rectangle at {self.x}/{self.y} with dimensions {self.width}x{self.height}"

class Square:
    def __init__(self, x, y, side, color="black"):
        self.x = x
        self.y = y
        self.color = color
        self.side = side
        
    def area(self):
        return self.side**2
        
    def __str__(self):
        return f"A {self.color} Square at {self.x}/{self.y} with side length {self.side}"
c1 = Circle(10, 10, 1.784)
r1 = Rectangle(15, 10, 5, 8, "blue")
s1 = Square(1, 1, 20, "green")
shapes = [c1, r1, s1]
print([ x.color for x in shapes])
print([ x.area() for x in shapes])
[ str(x) for x in shapes ]
# The Problem
Redundancy plagues our code!

* **Code Redundancy**: Both the constructor (`__init__`) and the `__str__` method contain a lot of duplicate code. If we want to change the way shapes are initialized or printed, we need to modify each shape individually.
* **Difficulty in Maintenance**: As we must modify three classes everytime, we have 3x more chances to mess up and introduce bugs. What if for some reason, we want `x` to be known as `coord_x` in the future? We would have to rename it in six different places, and hopefully not make any mistakes.
* **Lack of Code Reusability**: If we want to add another shape (e.g. a Triangle), we cannot re-use any of our code and have to implement another whole class.
* **Difficulty in External Use**: If we give our code to someone else, they cannot confidently assume uniformity across the shape classes. Each class possesses its unique methods and attributes, demanding meticulous scrutiny. This lack of consistency complicates the integration of our shapes into external applications, hindering seamless collaboration and interoperability.


# The Solution: Inheritance
Inheritance is one of the fundamental pillars of OOP. When declaring a new class, inheritance allows us to re-use functionality (attributes and behavior) from existing classes.

In the following code, we create a new class `Shape`, which will serve as a **superclass** to each of our individual shapes. As such, `Circle`, `Rectangle` and `Square` become **subclassess** of `Shape`. Our new `Shape` class will specify the attributes and behavior shared by all shapes, namely:
 * Attributes: Any shape has x and y coordinates, and a color
 * Behavior: Any shape has an area that can be calculated, and any shape can be printed somehow

However, all we know regarding the area calculation is that **it exists**, but we don't know how exactly each shape will calculate the area. For this reason, the `Shape`'s `calculate_area` method remains un-implemented. As for printing a Shape, we can communicate the coordinates and the color, but nothing else.

Let's focus on `Shape` and `Circle` for now:
from math import pi

class Shape:
    def __init__(self, x, y, color="black"):
        self.x = x
        self.y = y
        self.color = color

    def area(self):                                     # EVERY shape has an area function, so we place the method signature here
        pass                                            # However, HOW each shape calculates the area is unknown, so no implementation here

class Circle(Shape):                                    # Circle *inherits* from Shape
    def __init__(self, x, y, radius, color="black"):    # Circle still takes the same constructor parameters
        super().__init__(x, y, color)                   # But instead of saving them as attributes here, we call the SUPER-CONSTRUCTOR
        self.radius = radius                            # Only the radius is saved here, because that's the only Circle-specific attribute

    def area(self):
        return pi * self.radius**2                      # Circle provides its specific area implementation

    def __str__(self):
        return f"A {self.color} Circle at {self.x}/{self.y} with radius {self.radius}" # unchanged for now
To summarize the modifications to our implementation:
 1. We added a `Shape` class that takes coordinates and color as constructor parameters.
 1. We made `Circle` inherit from `Shape` by adding it to the class signature:`Circle(Shape)`.
 1. We moved saving the coordinates and color (`self.x = x`, ...) from Circle to Shape
 1. We added a non-implemented `area` method to Shape, indicating that every Shape should support an area calculation.
 1. In `Circle`, we call the **super-constructor** to initialize the coordinates and color: `super().__init__(x, y, color)`.

The behavior of `Circle` is unchanged. Everything works exactlye the same:
c1 = Circle(10, 10, 1.784)
print(c1)
print(c1.radius)
print(c1.area())
Here's what happens whe one class (`Circle`) inherits from another class (`Shape`):
 1. The entire implementation of `Shape` is essentially "copy-pasted" into `Circle`.
 1. Any attributes or methods in `Circle` that have the same name as in `Shape` are **overriden**. Above, this is true for the `__init__` and `__area__` methods.

You might think what's the point, if `Circle` overrides everything in `Shape`. Well, the implementations in `Shape` are not lost. In particular, we still want to use `Shape.__init__` when instantiating a `Circle`. For this reason, we need to call the `Shape` constructor inside the `Circle` constructor:
### `super()` for initialization

In our geometric example, both `Shape` and `Circle` need to implement a constructor (`__init__`), because each class has some distinct attributes that need to be set. In `Circle.__init__` we set the radius, while in `Shape.__init__` we set the coordinates and color. This requires us to call the `super().__init__` constructor in `Circle`. The sequence of events when creating a new `Circle` object...
c1 = Circle(9, 9, 3) # create a new Circle object at 9/9 with radius 3
 1. The Circle constructor `Circle.__init__` is called with all necessary parameters to create a `Circle`. `self` refers to the same object as `c1`.
 2. The very first thing that the constructor does, is call `super().__init__`, which corresponds to `Shape.__init__`, with the necessary parameters
 3. In the Shape constructor `Shape.__init__`, the coordinates and color are saved as attributes of the circle object (`self`).
 4. When the Shape constructor is done, the rest of the Circle constructor is executed, also setting the radius of the circle object (`self`)

In such cases, where you need to call the parent constructor (`super().__init__`), **you usually do this first**, before doing any other initialization (e.g., before setting `self.radius`) to preserve a meaningful order of execution. Here is a general example:
class Superclass:
    def __init__(self, name):
        print("called Superclass constructor - start")
        self.name = name
        print("called Superclass constructor - end")

class Subclass(Superclass):
    def __init__(self, name, age):
        print("called Subclass constructor - start")
        super().__init__(name)                          # first real thing to happen in __init__ is to call super().__init__
        print("called Subclass constructor - middle")
        self.age = age
        print("called Subclass constructor - end")

s = Subclass("Bob", 33)
print(s.name)
It's important to realize that the superclass' constructor will **not** be called automatically. For example:
class Superclass:
    def __init__(self, name):
        self.name = name

class Subclass(Superclass):          # Just inheriting from Superclass does NOT somehow automatically use the Superclass.__init__ constructor
    def __init__(self, name, age):
        self.age = age               # not calling the super constructor, self.name is never set!
        
s = Subclass("Bob", 33)
#print(s.name)                       # AttributeError: 'Subclass' object has no attribute 'name'
On the other hand, if the child class does not override a method, then it retains the parent's implementation. For example:
class Superclass:
    def __init__(self, name):
        self.name = name

class Subclass(Superclass):                # Subclass does not override __init__, thus Superclass' __init__ is "copy-pasted" into Subclass
    def speak(self):
        print(f"My name is {self.name}")

s = Subclass("Bob")                        # This calls Subclass.__init__(s, "Bob"). This method exists, because it's inherited from Superclass
print(s.name)
s.speak()
And just to be clear, don't mindlessly add constructors and `super()` calls if they are not necessary. Here is an example for an inheritance tree that does not require such calls:
class Printable:               # This "mixin" will work for any subclasses that have a .name attribute
    def print_me(self):
        print(self.name)       # Printable does not itself set self.name. It would need to be set by any subclass inheriting Printable

class Person(Printable):
    def __init__(self, name):  # no need to call super().__init__ because the superclass does not specify any special thing to do when initializing (no __init__ method)
        self.name = name

p = Person("Mary")
p.print_me()
### `super()` for arbitrary methods

It's not just in the constructor (`__init__`) that you might want to call the parent method with the same name. In the following example, the parent class provides some functionality in `ask`, which the child class can use:
class Order:
    def __init__(self, value):
        self.value = value

    def ask(self):
        return f"give me the {self.value}"

class PoliteOrder(Order):
    def ask(self):
        return f"please {super().ask()}"     # Re-uses parent implementation of ask, but adds something to it

p = PoliteOrder("money")
print(p.ask())
In our geometric example, we can also make use of this. In the existing implementation below, the `__str__` implementations of each specific shape repeat the part about coordinates and the color:
class Circle(Shape):
    #...
    def __str__(self):
        return f"A {self.color} Circle at {self.x}/{self.y} with radius {self.radius}"

class Rectangle(Shape):
    #...
    def __str__(self):
        return f"A {self.color} Rectangle at {self.x}/{self.y} with dimensions {self.width}x{self.height}"

class Square(Shape):
    #...
    def __str__(self):
        return f"A {self.color} Square at {self.x}/{self.y} with side length {self.side}"
**Every** `Shape` has coordinates and a color, so why not implement `Shape`'s __str__ method, rather than repeating it in each subclass?

Here is the same implementation again, but now we add method `Shape.__str__` and make `Circle.__str__` call it via `super().__str__()`
from math import pi

class Shape:
    def __init__(self, x, y, color="black"):
        self.x = x
        self.y = y
        self.color = color

    def area(self):
        pass

    def __str__(self):
        return f"A {self.color} Shape at {self.x}/{self.y}"       # Added __str__ with information we know for any shape

class Circle(Shape):
    def __init__(self, x, y, radius, color="black"):
        super().__init__(x, y, color)
        self.radius = radius

    def area(self):
        return pi * self.radius**2

    def __str__(self):
        return f"{super().__str__()} with radius {self.radius}"   # Calling super().__str__() to generate the first half of the returned string

c1 = Circle(10, 10, 1.784)
print(c1)
So now, when printing a Circle object (e.g., `c1`), the following sequence of operations is executed:
 1. `Circle.__str__(c1)` is called
 1. Inside `Circle.__str__` the f-string is evaluated
 1. `super().__str__()` is called. This corresponds to `Shape.__str__`. Thus, `Shape.__str__(c1)` is executed
 1. `Shape.__str__(c1)` returns the resulting string with infos about the color and coordinates. The returned string is placed in the f-string.
 1. The rest of the f-string is evaluated (`self.radius`)
 1. `Circle.__str__(c1)` returns the resulting string, now also containing the radius.

Only small problem: `Shape.__str__` mentions just being a `"Shape"`. Can we use the correct name for each shape? Of course. We have two options:

Option 1: we move the name itself back to `Circle` by rearranging the string a bit:
from math import pi

class Shape:
    def __init__(self, x, y, color="black"):
        self.x = x
        self.y = y
        self.color = color

    def area(self):
        pass

    def __str__(self):
        return f"{self.color} color at {self.x}/{self.y}"                     # Don't mention "Shape"

class Circle(Shape):
    def __init__(self, x, y, radius, color="black"):
        super().__init__(x, y, color)
        self.radius = radius

    def area(self):
        return pi * self.radius**2

    def __str__(self):
        return f"A Circle of {super().__str__()} with radius {self.radius}"   # Re-arrange so we can mention Circle here

c1 = Circle(10, 10, 1.784)
print(c1)
Option 2 (advanced, not going to be in the exam): we make use of **Reflection** inside Shape to figure out what kind of concrete object we actually have:
from math import pi

class Shape:
    def __init__(self, x, y, color="black"):
        self.x = x
        self.y = y
        self.color = color

    def area(self):
        pass

    def __str__(self):
        return f"A {self.color} {self.__class__.__name__} at {self.x}/{self.y}"   # Use reflection (self.__class__.__name__) to figure out concrete Shape type

class Circle(Shape):
    def __init__(self, x, y, radius, color="black"):
        super().__init__(x, y, color)
        self.radius = radius

    def area(self):
        return pi * self.radius**2

    def __str__(self):
        return f"{super().__str__()} with radius {self.radius}"   # Prior version

c1 = Circle(10, 10, 1.784)
print(c1)
# Abstract Classes

So far so good. There is just one small hick-up with the current implementation: What does it mean to instantiate a `Shape`?
a_shape = Shape(10, 15, "red")
print(a_shape)
It works, but again, what does this mean? How should I imagine what a "Shape" looks like? And what is the area of a `Shape`?
a_shape = Shape(10, 15, "red")
print(a_shape.area())
Really, the idea of a "shape" is an *abstract* concept. Circles, rectangles and triangles are *concrete* examples for shapes. Likewise, the idea that "a shape has an area" is also *abstract*. How exactly that area is computed depends on the specific Shape.

For this reason, Python (and many other programming languages) support the concept of **abstract classes**. An abstract class also specifies attributes and behavior, but it is intended **only to be used as a super-class** for other classes, and not to be instantiated directly.

Abstract classes contain **abstract methods**. Since each `Shape` absolutely has an area, but computing it depends on its specific type, we can mark `Shape.area()` as an abstract method:
from abc import ABC, abstractmethod                # necessary scaffolding to work with abstract classes
from math import pi

class Shape(ABC):                                  # Shape is an abstract class. In Python, this means inheriting from ABC
    def __init__(self, x, y, color="black"):
        self.x = x
        self.y = y
        self.color = color

    @abstractmethod                                # area is an abstract method, thus we annotate it with @abstractmethod
    def area(self):                                # the rest of this code is unchanged
        pass

    def __str__(self):
        return f"A {self.color} {self.__class__.__name__} at {self.x}x{self.y}"

class Circle(Shape):
    def __init__(self, x, y, radius, color="black"):
        super().__init__(x, y, color)
        self.radius = radius

    def area(self):
        return pi * self.radius**2

    def __str__(self):
        return f"{super().__str__()} with radius {self.radius}"   # Unchanged

c1 = Circle(10, 10, 1.784)
print(c1)
To mark a class as *abstract* in Python, it needs to inherit from `ABC`. To mark a method as *abstract*, it is annotated with `@abstractmethod`.

This has the side-effect that we can also no longer instantiate `Shape` (which makes sense, finally):
#a_shape = Shape(10, 15, "red")     # won't work anymore
Here is the complete implementation for all three shapes:
from abc import ABC, abstractmethod
from math import pi

class Shape(ABC):
    def __init__(self, x, y, color="black"):
        self.x = x
        self.y = y
        self.color = color

    @abstractmethod
    def area(self):
        pass

    def __str__(self):
        return f"A {self.color} {self.__class__.__name__} at {self.x}x{self.y}"

class Circle(Shape):
    def __init__(self, x, y, radius, color="black"):
        super().__init__(x, y, color)
        self.radius = radius

    def area(self):
        return pi * self.radius**2

    def __str__(self):
        return f"{super().__str__()} with radius {self.radius}"
        
class Rectangle(Shape):
    def __init__(self, x, y, width, height, color="black"):
        super().__init__(x, y, color)
        self.width = width
        self.height = height
        
    def area(self):
        return self.width*self.height

    def __str__(self):
        return f"{super().__str__()} with dimensions {self.width}x{self.height}"

class Square(Shape):
    def __init__(self, x, y, side, color="black"):
        super().__init__(x, y, color)     
        self.side = side
        
    def area(self):
        return self.side**2
        
    def __str__(self):
        return f"{super().__str__()} with side length {self.side}"
c1 = Circle(10, 10, 1.784)
r1 = Rectangle(15, 10, 5, 8, "blue")
s1 = Square(1, 1, 20, "green")
shapes = [c1, r1, s1]
print([ x.color for x in shapes])
print([ x.area() for x in shapes])
[ str(x) for x in shapes ]
# Deep inheritance

Inheritance is not limited to a single level. This is already illustrated in the example above: `Rectangle` inherits from `Shape`, and `Shape` inherits from `ABC`. We can further illustrate this by realizing that really, a square is just a special case of a rectangle, where both height and width are equal. Even the area calculation is essentially the same! So why not make `Square` a subclass of `Rectangle`?   
class Rectangle(Shape):
    def __init__(self, x, y, width, height, color="black"):
        super().__init__(x, y, color)
        self.width = width
        self.height = height
        
    def area(self):
        return self.width*self.height

    def __str__(self):
        return f"{super().__str__()} with dimensions {self.width}x{self.height}"

class Square(Rectangle):                                  # The Square class is now super simple!
    def __init__(self, x, y, side, color="black"):        # It takes the same constructor parameters as before
        super().__init__(x, y, side, side, color)         # But instead of saving any attributes in its constructor, it just calls the parent constructor with 'height' and 'width' both being 'side'

s1 = Square(34, 77, 10, "green")     # side 10 is passed on as width=10, height=10 to the Rectangle constructor
print(s1)                            # calls Rectangle.__str__(s1) which in turn calls Shape.__str__(s1) for part of the f-string
print(s1.area())                     # calls Rectangle.area(s1)
### Summary

* Classes can inherit from other classes: `Circle(Shape)`, `Shape(ABC)`. This forms an "inheritance tree" which can span many levels.
 * When a class Child inherits from a class Parent, then class Child ...
   * can call the super-class methods: `super().__init__(x, y, color)`, `super().__str__()`.
   * can access any attributes that are set by super-class code: `self.x`, which makes sense because when doing `super().__init__()`, the super-class' `__init__` method receives the same object (`self`), so it just adds attributes to it.
 * Classes can be "abstract" if they are not really supposed to be instantiable like regular "concrete" classes would be. Abstract classes typically contain "abstract methods", which do not provide any implementation, but need to be implemented in sub-classes.
 * Abstract classes in Python inherit from `ABC`.
 * Abstract methods in Python are annotated with `@abstractmethod`.
### A word on "private"

Many languages (most prominently: Java) provide a mechanism to "hide" attributes that are only to be used within the logic of a class (i.e., the methods of a class), but should not be accessible from "outside" the class.

Python **does not have private**. Best it can do is "non-public". If you want to know all the details, read the couple of paragraphs in PEP8 and follow the Pythonic guidelines listed:

[https://peps.python.org/pep-0008/#method-names-and-instance-variables](https://peps.python.org/pep-0008/#method-names-and-instance-variables)

In short:
 * Object attributes that should be accessible from outside (e.g., `Circle.radius`) should have *no* leading underscore (`_`)
 * Don't implement getters/setters (`Circle.get_radius()`, `Circle.set_radius()`) - just get/set the attribute directly (`print(Circle.radius)`, `Circle.radius = 7`).
 * If you want to indicate to others that some attributes or methods should only be used internally, you may prefix them with a single underscore (e.g., `self._name = ...`)
 * If you wanna be a real pro, learn all about Python's [data model](https://docs.python.org/3/reference/datamodel.html) and implement custom [attribute access](https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access)
 * If (and only if) your class is intended to be subclassed, consider leading attribute names with `__` (double underscore). This will "mangle" that attribute name:
class Superclass:
    def __init__(self, name):
        self.name = name
        self.__data = {}     # Mangled to self._Superclass__data outside Superclass

    def print_data(self):
        print(f"Superclass self.__data: {self.__data}") # Here it's normal

s1 = Superclass("Superclass")
print(s1.name)
#print(s1.__data)            # AttributeError, it doesn't exist!
print(s1._Superclass__data)  # Here we must use the mangled name
s1.print_data()
In this example, `Superclass` refers to an attribute `self.__data` in it's constructor. Within the class, for example in `print_data`, this attribute is known as such.

However, outside of the class scope, it is **not** known as such. Python "mangles" the attribute name such that it becomes `s1._Superclass__data`.

The main point of this not to avoid externel code from messing with attributes, because it is assumed that the programmer using the class will know what they're doing with existing attributes. If they want to modify an attribute, so be it.

The main point is to avoid a subclassing programmer from accidentally breaking the superclass by naming an attribute the same as an existing attribute used by the superclass!

In the example below, some guy wrote `Superclass` which does some useful things. It creates an empty **tuple** referenced by `self.data` in `Superclass.__init__`, which it somehow needs to work correctly. Now, you want to subclass this useful class, so you write a `Subclass`. You want to store some data, so you define a `self.data` attribute in `Subclass.__init__` (an empty **set**) but by chance, this overwrites an attribute required by Superclass to work correctly:
class Superclass:                   # Written by Robert Paulson some time in 2007. You don't know this code.
    def __init__(self, name):
        self.name = name
        self.data = tuple()         # (1) not protected
        self.__data = {}            # (2) kinda protected, will be mangled outside this class' scope

    def do_something_with_data(self):
        '''This useful method needs self.data to be a tuple'''
        print(type(self.data) == tuple)    # This will be False for Subclass instances!
        print(type(self.__data) == dict)

class Subclass(Superclass):         # Written by YOU right now without internal knowledge of Superclass
    def __init__(self, name):
        super().__init__(name)
        self.data = set()           # (3) this accidentally overwrites (1)
        self.__data = []            # (4) this does NOT overwrite (2)
        
super_class = Superclass("Superclass")
sub_class = Subclass("Subclass")
print(sub_class.name)
print(sub_class.data)              # set in Subclass constructor (3), overwrote (1)
print(sub_class._Subclass__data)   # set in Subclass constructor (4) 
print(sub_class._Superclass__data) # set in Superclass constructor (2)

sub_class.do_something_with_data() # is expected to work correctly (2x True), but it does not!
# Unified Modelling Language (UML)
UML, is a standardized modeling language developed to help software engineers specify, visualize, and document artifacts of software systems. 

<div>
<img src="./uml.png" width="600px"/>
</div>

In the diagram above we can see our abstract class `Shape` (with its class name in *italic* font) and its descendants. We also imagine that a `Canvas` class will aggregate 0 or more shapes to be drawn on screen.
<div><img src="umlNotation.jpg" alt="drawing" width="300"/></div>

Relationships:
* Association: class A **is associated** with class B
* Inheritance: class A **is a** class B / class A **inherits** class B
* Realization: class A **realizes** class B / class A **implements** interface B
* Dependency: class A **uses** class B
* Aggregation: class A **has a** class B
* Composition: class A **owns** a class B

Cardinality:
 * Exactly one: 1
 * One or more: 1+
 * Optional: 1?
 * Bounded: 1..10
 * Unbounded: * (0..n)

You don't need to know all the details of UML, but you need to be able to read basic diagrams communicating inheritance, attributes, methods, and cardinality.
# Polymorphism
Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables a single class to represent different underlying forms (types). Polymorphism ensures that the correct method is called based on the object's actual type.
class Canvas:
    def __init__(self, shapes):
        self.shapes = shapes
                                                    # This is "Polymorphism":
    def calculate_total_area(self):                 # Canvas can treat all Shapes the same. It knows nothing about their internal implementation.
        return sum(s.area() for s in self.shapes)   # Each area() call is transparently dispatched to a different implementation!

c1 = Circle(10, 10, 1.784)
r1 = Rectangle(15, 10, 5, 8, "blue")
s1 = Square(1, 1, 20, "green")
shapes = [c1, r1, s1]

canvas = Canvas(shapes)
canvas.calculate_total_area()
Wherever a `Shape` is expected, `Circle`, `Rectangle`, and `Square` are all valid objects.
### Benefits of Polymorphism:
<b>Flexibility and Extensibility:</b> Polymorphism allows for easy addition of new classes without modifying existing code, enhancing the code's flexibility and extensibility.

<b>Modularity:</b> Polymorphic interfaces promote modularity by allowing classes to interact through well-defined interfaces, reducing dependencies between classes.

<b>Code Reusability:</b> Polymorphism encourages the reuse of code. Methods defined in base classes can be reused across multiple subclasses, promoting efficient code reuse.

<b>Simplified Code:</b> Polymorphism simplifies code by enabling the use of generic interfaces, making it easier to understand and maintain complex systems.

In summary, polymorphism is a powerful OOP concept that promotes flexibility, modularity, and code reuse by allowing objects of different types to be treated uniformly through a common interface or base class. Understanding and leveraging polymorphism are essential skills for effective object-oriented software design.
# Another polymorphic example

<span style="color:purple;font-weight:bold">Exercise</span>

You are implementing a basic system for storing files and folders. Follow these implementation guidelines:

 * Every file has a name
 * Text files also store some text content
 * Image files also store a 2D-collection of pixels (which can be either 1 or 0) to form a black and white picture
 * Folders are special files that store a collection of files
 * For any kind of file, it should be possible to determine the file size
   * For text files, the file size corresponds to the length of the text
   * For image files, the file size is the number of pixels
   * For folders, the size is the sum of sizes of files contained
 * For any kind of file, it should be possible to print it to the command line, starting with its file name and:
   * For text files, the text content
   * For image files, the pixels as 'â–ˆ' or 'â–‘' if 1 or 0.
   * For folders, the filenames of files contained

Consider the following example of how your implementation would be used:
```python
t1 = TextFile("haiku.txt",       # Create a new TextFile
"""Indentation woes
Syntax errors multiply
Debug, try again""")

i1 = ImageFile("smile.img", (    # Create a new ImageFile
    (0, 1, 0, 1, 0),
    (0, 0, 0, 0, 0),
    (1, 0, 0, 0, 1),
    (0, 1, 1, 1, 0),
))

f = Folder("My Documents")       # Create a new Folder
f.content.extend([t1, i1])       # Add files to the folder
print(t1.get_size())             # Text size
print(i1.get_size())             # Image size
print(f.get_size())              # Folder size (sum of content sizes)
print(t1)                        # Print haiku
print(i1)                        # Print smiley-face
print(f)                         # Print folder content
```
Which should result in the following output:
```
56
20
76
haiku.txt:
Indentation woes
Syntax errors multiply
Debug, try again
smile.img:
â–‘â–ˆâ–‘â–ˆâ–‘
â–‘â–‘â–‘â–‘â–‘
â–ˆâ–‘â–‘â–‘â–ˆ
â–‘â–ˆâ–ˆâ–ˆâ–‘
My Documents:
 - haiku.txt
 - smile.img
```# Office Hours

Thursday's office hours have been moved to Center Campus, 12:15 in KO2-F-155

# Midterm

Your results will be ready when they're ready :o)

# Reflection

We recently touched upon **reflection**, when we determined the name of a class:
class Something:
    pass

s = Something()
print(s.__class__.__name__)
Using reflection, given some arbitrary value, you can figure out various things about it. You already know how to determine the type of a value:
some_val = "hello"
type(some_val)
type(1)
This is a very simple form of reflection. However, Python will readily tell you much more about an object. For example, you can use the `dir` function to get a list of all the members (attributes and methods) of an object:
dir("hello")
Note that if you create a new class (or function, or any value for that matter...), it ships with a lot of built-in functionality:
class Person:
    def __init__(self, name):
        self.name = name
p = Person("Bob")
print(p)                  # when printing an object, str(...) is called automatically
print(str(p))             # str(...) is just a shorthand for __str__
print(Person.__str__(p))  # __str__ is a member of Person even though we did not implement it ourselves - it's inherited from <object>
You can see here that `Person` already implements `__str__`, because all classes do by default. You can see that the object of type `Person` called `p` has many members already (including __str__, for example, but also the custom `name` that we added ourselves):
dir(p)
Furthermore, note how the `__class__` attribute of a `Person` **instance** `p` points to the actual class `Person`:
p = Person("Bob")
print(p)
print(Person)
print(p.__class__)
p.__class__ is Person      # same object!
Here are all the things that integers support:
dir(11)
Of course, Python provides special syntax for numbers, and we can't just call these methods simply because the syntax forbids it:
#print(11.__class__)        # SyntaxError
The simple way to get around this is to put braces around the "syntactically special" value:
print((11).__class__)
Or you could just assign the number to a variable and then use that to refer to the int object's members. Either way, you can see that it, too, like any other object, has a bunch of built-in members:
i = 11
print(i.__class__)
dir(i.__class__)
For example:
print(type((3).to_bytes))
for i in range(6):
    print(i.to_bytes())
# Special Methods

By now you will have noticed that there are more "special methods" than just `__init__`, `__str__` and `__repr__` which we discussed in previous lectures. You don't need to know about all of them, but a few of them are quite common and important. You can learn all about them in the [Python documentation](https://docs.python.org/3/reference/datamodel.html#special-method-names).

Let's see a few examples:

## Rich comparison operators

You already know that you can compare two integers
3 > 1
or also two strings (which will be compared lexicographically).
"a" < "b"
You also know how calling `print(something)` will internally call `something.__str__()`:
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def __str__(self):
        return f"{self.name} ({self.age})"
p1 = Person("Bob", 33)
print(p1)
Just the same, `some_a > some_b` will internally call `some_a.__gt__(some_b)`. Here are two examples for this:
(3).__gt__(1)     # same as 3 > 1
"A".__lt__("B")   # same as "A" < "B"
So the `int` class implements a function `__gt__` ("greater than") which takes one additional parameter ("the other integer") and returns a boolean. As such, any *comparable* class implements the following methods, which have their corresponding syntactic sugar:

 * `__gt__` for `>`: **g**reather **t**han
 * `__lt__` for `<`: **l**ess **t**han
 * `__ge__` for `>=`: **g**reater than or **e**qual to
 * `__le__` for `<=`: **l**ess than or **e**qual to
 * `__eq__` for `==`: **eq**ual to
 * `__ne__` for `!=`: **n**ot **e**qual to

So if we want to make our own classes comparable, we just need to implement those methods. Python is actually clever enough to fill in the gaps if we don't implement all of the methods!

Let's say we want `Person`s to be ordered and compared by their age (ignoring the name for the purpose of this comparison).
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def __str__(self):
        return f"{self.name} ({self.age})"
        
    def __lt__(self, other):
        return self.age < other.age
        
    def __le__(self, other):
        return self.age <= other.age
        
    def __eq__(self, other):
        return self.age == other.age
Now, instances of `Person` can be compared using the usual operators, just like numbers:
p1 = Person("Bob", 32)
p2 = Person("Alice", 44)
p1 > p2
We can confirm that this indeed works for all operators:
p1 = Person("Bob", 32)
p2 = Person("Alice", 44)
p3 = Person("Jim", 32)
for a in [p1, p2, p3]:
    for b in [p1, p2, p3]:
        if a is not b:                      # skip comparisons between identical objects (like p1 > p1)
            print(f"{a} < {b}: {a < b}")
            print(f"{a} > {b}: {a > b}")
            print(f"{a} <= {b}: {a <= b}")
            print(f"{a} >= {b}: {a >= b}")
            print(f"{a} == {b}: {a == b}")  # equivalence comparison using '=='
            print(f"{a} != {b}: {a != b}")
*Sidenote 1*: There are some caveats to this automatic inference. As a general rule, you *should* implement all methods just for clarity. Or you could use [@total_ordering](https://docs.python.org/3/library/functools.html#functools.total_ordering) to infer more operators.

*Sidenote 2*: Remember that False and None can easily be mistaken to be one and the same when used in an `if` condition. If you're implementation of an operator accidentally returns `None`, that may count as `False` when actually used!

*Sidenote 3*: Even the dot-notation `p1.age` internally calls `__getattr__` and `p1.age = 21` calls `__setattr__`! Python's [Data model](https://docs.python.org/3/reference/datamodel.html) is extremely flexible and powerful!
# `NotImplemented` for rich comparison operators

The following implementation of `Bill` (as in paper money) assumes that two instances are equal if they have the same denomination. This works fine for comparing different instances of `Bill`.
class Bill:
    def __init__(self, denomination):
        self.denomination = denomination
        
    def __eq__(self, other):
        return self.denomination == other.denomination

b1 = Bill(50)
b2 = Bill(50)
b3 = Bill(1000)
print(b1 == b2)
print(b1 is b2)
print(b1 == b3)
However, think of how `==` is generally used: **it's not at all unusual to compare objects of different types**:
def index_of(thing, collection):
    for index, element in enumerate(collection):
        if element == thing:
            return index

index_of("hello", [123, ("I'm a tuple", 1.5), "hello", "world"])
Our `Bill` implementation works when comparing to other `Bill`s:
index_of(Bill(50), [Bill(10), Bill(20), Bill(50), Bill(100)])
But if we try using our `index_of` function to spot a specific `Bill` among arbitrary objects, we run into a problem:
index_of(Bill(50),[123, ("I'm a tuple", 1.5), "hello", Bill(50), "world"])
For this reason, it is highly recommended to **return** `NotImplemented` if comparing to the `other` object is not possible:
class Bill:
    def __init__(self, denomination):
        self.denomination = denomination
        
    def __eq__(self, other):
        if not isinstance(other, Bill):
            return NotImplemented
        return self.denomination == other.denomination
Now, we can use `index_of` because Python internally realizes that two non-comparable objects are not equal:
index_of(Bill(50),[123, ("I'm a tuple", 1.5), "hello", Bill(50), "world"])
**Important**: `NotImplemented` is a not an exception. You do **not** `raise NotImplemented`! You have to `return NotImplemented`.
## Hashing

Finally, we come back to *mutable* vs. *immutable*. Early on in the lecture, you learned that only *immutable* values can be used as dictionary keys: 
d = {(1, 2): "OK"}
d = {[1, 2]: "NOT OK"}   # TypeError: unhashable type: 'list'
d[(1,2)]
This is primarily because only immutable values implement the `__hash__` method. For example, see how both tuples and lists have a `__hash__` member, but the one for lists is `None`:
print("__hash__" in dir([]))
print("__hash__" in dir(()))
print([].__hash__)
print(().__hash__) 
Just like `>` internally calls `__gt__` and how `str(...)` calls `__str__`, so does the `hash(...)` function call the objects `__hash__` function.

### What does the `__hash__` function do?

All the `__hash__` function does is return an integer:
print(hash("hello"))
print(hash(2))
print(hash(3))
print(hash(print))
print(hash(int))
Now what could possibly be the point of this?

### The purpose of hashing

Imagine you run a library. How are visitors going to find the book they're looking for?

 * The worst strategy would be to just put books in any shelf and visitors will just have to start walking around aimlessly, picking up random books until they've found the right one. It may take a few millenia...
 * A more reasonable strategy would be to put all the books in alphabetical order (first by author last and first name, then by title) and have sort of "tour" from A to Z that a visitor can follow until reaching the right book. Good for books by Douglas **A**dams, very bad for books by Jules **V**erne.
 * Of course, there's an even better (and cheap!) strategy, which most libraries still use today. You simply make up a rule that allows a customer to determine which shelf in the library a particular book can be found on. This usually works something like this:
   1. If you're looking for the book "Brave New World" by "Aldous Huxley", you will need to look at the first two letters of the last name of the author: `HU`
   2. Go to the shelf labelled `HU`
   4. Go through the (alphabetically sorted) books one by one until you found the book you wanted

This cuts down the effort of finding the book from going all they way from `A` to `Hu` to just looking at all the books on the shelf labeled `HU`, a drastic decrease!

**What we've done here is create a hash!** In this scenario, the *hash* of a book is simply the first two letters of the author's last name. What's great about this approach that it's very cheap to compute the hash of a book, and it's also very simple to organize books using this fashion.

### *Hash collisions* and *Uniformly distributed hashes*

With the given hash method, you will need around $26*26$ shelves that are easy to find. Of course, that's a lot of shelves, and not all shelves will be equally stocked. There are way fewer authors starting with `Qv` than with `Sm`. In practice, what we want is a *uniformly distribued* hash function. That means that each shelf (in programming, we call it a "*bucket*") will contain the same number of elements. Libraries actually do the same thing: The "hash" of a book with author "Smith, Jack" may be `SMITHJ` because there are so many authors called "Smith", while an author called "Qvist, Aaron" may have a hash of just `Q`.

### Hashes in Python

Just like a library will use hashes to stock books, Python uses hashes to store elements in data structures such as dictionaries and sets. Imagine you have a dictionary where each key is a string like `"Huxley, Aldous: Brave New World"` and the value contains the entire text of a book. Imagine you store millions of books. Of course, when you wish to retrieve your book...

```
my_great_library["Huxley, Aldous: Brave New World"]
```

Python will *not* aimlessly wander around or check dictionary keys one by one. Instead, it will use a strategy just like the library to find the book much more quickly (for example using a so-called hashmap). That's why so many objects have a `__hash__` function. Hashes in Python are not character sequences like in our library example, but simple integers:
hash("Huxley, Aldous - Brave New World")
Depending on the strategy used and how many values are being stored, Python could for example decide that this book will be found on shelf `-4911629686054464894`, taking the whole hash, or maybe on shelf `94`, taking the last two digits of the hash, depending on how many books there are and how many shelves/buckets are needed. A different book:
hash("Orwell, George - Animal Farm")
may be found on shelf `39`. Of course, hash collisions (where two data will be placed in the same bucket) still exist:
hash("Bradbury, Ray - Fahrenheit 451")
*Sidenote*: Every time Python is restarted, it will produce different hashes, even given the same data. This is done to prevent certain types of attacks. See the [grey box in the `__hash__` documentation](https://docs.python.org/3/reference/datamodel.html#object.__hash__). For this notebook, I prevented this by setting the `PYTHONHASHSEED` environment variable, for example: `PYTHONHASHSEED=341 jupyter-notebook 07_special_hash_exceptions.ipynb`.
### Implications of hashing

There are a few things to be aware of:

 * When computing a hash of an object repeatedly, **the hash must always stay the same!** If the author were to chang their name from "Huxley" to "Buxley", the book would be left on shelf `HU` but the customer would walk to shelf `BU`. That's why, generally, only immutable values implement `__hash__`.
 * Two objects with the same hash *could* be equivalent, but they don't have to be (if it's just a hash collision).
 * Two objects that are equivalent (`a == b`) *must* have the same hash.
 * When looking for an object with a given hash...
   * ... finding an object with a *differing* hash *guarantees* that that object is not what we're looking for
   * ... finding an object with the *same* means we'll have to look more closely at the object (because maybe it's just a hash collision)
  
It's *strongly* recommended that you simply [read the `__hash__` documentation](https://docs.python.org/3/reference/datamodel.html#object.__hash__), it only takes two minutes and gives all the necessary information.
### How to implement `__hash__`

Let's have a quick example of how you might implement `__hash__`. If `__hash__` is implemented, the three rules to are:

 * `__hash__` must return an integer
 * `__eq__` must also be implemented
 * if two objects are equal (`==`), then the hash computed by `__hash__` should be the same

Plus, of course, implementing `__hash__` implies that the object is **immutable**.
class Book:
    def __init__(self, author, title, content):
        self.author = author
        self.title = title
        self.content = content

    def __eq__(self, other):
        return self.author == other.author and self.title == other.title

    def __hash__(self):
        return 1           # totally valid, but not very useful (all elements will be put in the same bucket)

book1 = Book("Huxley, Aldous", "Brave New World", "Many megabytes of text here...")
book2 = Book("Huxley, Aldous", "Brave New World", "Many MBs of text here...")         # same book, different spelling
book3 = Book("Orwell, George", "Animal Farm", "A completely different book here...")
print(hash(book1))
print(hash(book2))
print(book1 == book2)
print(book1 is book2)
print(hash(book3))
The implementation above is already a *valid* implementation of `__hash__`. But it's far from ideal, because of hash collisions. In fact, all `Book` instances will always land in the same bucket (on the same shelf). The recommended way of implementing `__hash__` is to combine the hashes of the attributes involved, typically by putting them all in a tuple and then calling `hash` on the tuple (which uses the tuple's `__hash__` function):
class Book:
    def __init__(self, author, title, content):
        self.author = author
        self.title = title
        self.content = content

    def __eq__(self, other):
        return self.author == other.author and self.title == other.title

    def __hash__(self):
        return hash((self.author, self.title))  # "standard way" of implementing hash for new classes

book1 = Book("Huxley, Aldous", "Brave New World", "Many megabytes of text here...")
book2 = Book("Huxley, Aldous", "Brave New World", "Many MBs of text here...")         # same book, different spelling
book3 = Book("Orwell, George", "Animal Farm", "A completely different book here...")
print(hash(book1))
print(hash(book2))
print(book1 == book2)
print(book1 is book2)
print(hash(book3))
but in principle, it's completely up to you to decide how to implement it, so the original "library strategy" would also be valid. In the following example, `book1` and `book2` produce the same hash, because it is only based on the first two characters of the author, `"Hu"` meaning the hash is computed as `hash("Hu")`:
class Book:
    def __init__(self, author, title, content):
        self.author = author
        self.title = title
        self.content = content

    def __eq__(self, other):
        return self.author == other.author and self.title == other.title

    def __hash__(self):
        characters = self.author[:2]
        return hash(characters)

book1 = Book("Huxley, Aldous", "Brave New World", "Many megabytes of text here...")
book2 = Book("Huxley, Aldous", "Brave New World", "Many MBs of text here...")         # same book, different spelling
book3 = Book("Orwell, George", "Animal Farm", "A completely different book here...")
print(hash(book1))
print(hash(book2))
print(book1 == book2)
print(book1 is book2)
print(hash(book3))
Keep in mind that classes that implement `__hash__` must be considered immutable. Again, if you were to rename "Huxley" to "Buxley", then the hash would also change, completely defeating its purpose:
book1 = Book("Huxley, Aldous", "Brave New World", "Many megabytes of text here...")
print(hash(book1))
book1.author = "Buxley, Aldous"
print(hash(book1))

Given that our `Book` is now hashable, we could use instances of `Book` as dictionary keys.
book_reviews = {}
book_reviews[book1] = ["Fantastic!", "A must read, highly topical.", "It was boring and I didn't get it..."]
print(book_reviews[book1])
print(book_reviews)
But again, if we now were to change the book instance, then our dictionary can't find it anymore, giving us a KeyError:
book1.author = "Fuxley, Aldous"
print(book_reviews[book1])        # can't find the book anymore, because its hash changed! Don't modify hashable objects!!!
print(book_reviews)
# Dealing with errors and exceptions

### `try` / `except` / `finally` / `else`

No doubt you've already met *exceptions*, such as `IndexError` or `ValueError`.
contacts = {"Alice": "+41001234567"}
contacts["Bob"]  # Will raise a KeyError
However, there's nothing particularily "bad" about errors and exceptions. They are essentially just a secondary flow of information in parallel to regular function returns used when things don't go "as they should normally". A common place where exceptions will likely need to be handled is if you allow humans to enter data into your application. See this example:
def beer_permitted():
    age = int(input(" > enter your age: "))    # a person could enter anything, not just numbers
    return age >= 16
beer_permitted()
This means that **exceptions are generally expected to happen**. For this reason, Python provides mechanisms to deal with them. You simply put code that might fail under certain conditions in a `try` block and then deal with a potential error in an `except` block:
def beer_permitted():
    while True:                                       # rare case where 'while' is appropriate, because we don't know how many times we have to do this
        try:
            age = int(input(" > enter your age: "))   # A ValueError could be raised here...
            return age >= 16
        except ValueError:                            # ... and will be dealt with here
            print("You must enter a number!")
beer_permitted()
In the example above, we specifically say that we only catch `ValueError`s by saying `except ValueError`. However, you can also just use `except` as a blanket-statement. This is generally not recommended, because you want your code to crash if it's not used correctly, so that you can care for individual problems one at a time.
The general syntax for  `try` / `except` / `finally` / `else` is:

```python
try:
    # try executing this code that could fail with any kind of exception
except SpecificError:
    # execute this code if a SpecificError occured
except AnotherSpecificError:
    # execute this code if AnotherSpecificError occured
except:
    # execute this code if ANY OTHER error occured ("catch-all", "blanket-statement", please use sparingly)
else:
    # execute this code only if NO exceptions occured
finally:
    # always execute this code, whether an exception occured or not
```
Here's a purely artificial example that you can modify to understand the program flow:
try:
    print("trying...")
except ValueError:
    print("ValueError occured")
except IndexError:
    print("IndexError occured")
except:
    print("some other exception occurred")
else:
    print("no exceptions occured")
finally:
    print("finally always executes")
Here's a more practical example:
def find_contact(contacts, name):
    return contacts[name]               # Will raise KeyError if name is not in contacts

def phone_as_int(number):
    return int(number[1:])              # Will raise ValueError if number[1:] cannot be read as an integer

def call(name):
    print("Picking up phone...")
    contacts = { "Alice": "+49001234567", "Bob": "+41001234567", "Ivan": "ivan@example.org"}
    try:
        phone = find_contact(contacts, name)
        number = phone_as_int(phone)
    except KeyError:
        print(f"{name} not in phonebook")
    except ValueError:
        print(f"{name}'s entry {phone} seems to be invalid")
    else:
        print(f"Calling {name}: {number}")
    finally:
        print("...Hanging up phone\n")

call("Alice")
call("Beatrice")
call("Ivan")

This is a very comprehensive example, but in real life, you primarily need to know about and use `try` with `except SomeException`. Note:

 * `else` is rarely used, as you could, in principle, move any code that's inside `else` to the end of the `try` block.
 * `finally` is typically used to clean up (for example closing open files, writing a log message, finalizing a transaction, etc.)
 * You should generally try to catch specific exceptions, rather than using a naked `except`, because doing the latter will mask potential issues that you're not aware of.
Using the `try`/`except` mechanism can also make your life easier. Consider this example:

You're retrieving data from some *unreliable* source, such as a human, and this data should be a number that can be converted to a hexadecimal number. As a reminder, we can convert any string representing a valid number of any base using the `int` function:
print(int("101", 2))
print(int("10"))        # default is base 10
print(int("ff", 16))
Now consider how you would implement a function that will receive some arbitrary string and convert it without crashing, if it represents a valid hexadecimal number? Without using `try`/`except`, you would probably resort to checking whether all characters are valid (`all` is a function that takes a collection and checks if all values are *truthy*):
def to_hex(string):
    if all(x in "0123456789abcdef" for x in string):
        return int(string, 16)
    else:
        return None
print(to_hex("af"))
print(to_hex("ag"))
But by using `try`/`except`, you can just go ahead and attempt the conversion without caring much about what is given to your function:
def to_hex(string):
    try:
        return int(string, 16)
    except:
        return None
print(to_hex("af"))
print(to_hex("ag"))
This means that when *validating* data that your function receives (is it really a number as expected? does the list have the expected number of elements? does the string have the expected length?), you have two choices:

 1. Explicitely check the value (like in the IP address validation task on ACCESS) to ensure it conforms to what you expect
 2. Use `try` wherever unexpected values may have been provided and handle problems in an `except` block

Of course, using `try`/`except` is not always a good option.
### Raising exceptions

When writing code, you may also want to `raise` your own exceptions and errors. Python provides a list of built-in exceptions [here](https://docs.python.org/3/library/exceptions.html#exception-hierarchy). As you can see, it's a hierarchy where many exceptions inherit from others. Given the rules of inheritance, that means that if you, for example `except LookupError`, this will catch both `KeyError` and `IndexError`, because they inherit from `LookupError`.

To cause an exception, you use the `raise` statement:
raise Exception
You can also add a custom message describing the problem in more detail:
raise Exception("the user did a bad thing")
Naturally, you can add you own exceptions, by simply inheriting from one of the existing Exception classes.

The following example is a bit redundant, but it illustrates the point:
class ContactNotFoundError(LookupError):
    pass

def find_contact(contacts, name):
    if name not in contacts:
        raise ContactNotFoundError
    return contacts[name]

contacts = {"Alice": "+41001234567"}
try:
    find_contact(contacts, "Bob")
except LookupError:                       # ContactNotFoundError inherits from LookupError, so it's also caught here
    print("nope")
Let's look at another example, this time involving classes:
class Person:
    def __init__(self, name, age, job):
        if job is not None and age < 18:
            raise ResourceWarning("Child labor is illegal")
        self.name = name
        self.age = age
        self.job = job
        
    def __repr__(self):
        return f"{self.name} is {self.age} years old {f'and works as a {self.job}' if self.job else ''}"

data_from_file = [
    ("Alice", 36, "Programmer"),
    ("Bob", 38, "Marketing Director"),
    ("Jimmy", 12, None),
    ("James", 18, "Waiter"),
    ("Lilly", 14, "Brain surgeon"),
]

population = []
invalid = []
for name, age, job in data_from_file:
    try:
        population.append(Person(name, age, job))
    except ResourceWarning:
        population.append(Person(name, age, None))
        invalid.append((name, age, job))
print(population)
print(invalid)
# Lesson's learned

You should...

 * know that you can use *reflection* to "inspect" objects, for example using `type` or `dir`.
 * be able to implement rich comparison operators (and other special methods such as `__len__` or `__round__` for arbitrary classes.
 * remember to *return* `NotImplemented` when for unsupported `other` types when implementing comparisons.
 * know the purpose of hashing and that hashes should be uniformly distributed.
 * be able to implement `__hash__` and know the rules the implementation must follow (must return an integer, `__eq__` must also be implemented, and if two objects are equal, they should have the same hash).
 * know how deal with exceptions by constructing `try`/`except SpecificException`/`except`/`else`/`finally` blocks.
 * know how to create custom exception classes and how to raise exceptions.# Recap
## Special Methods

Each "outside" operation, like...
3 > 1
....has a corresponding "inside" implementation:
(3).__gt__(1)     # same as 3 > 1
Some prominent examples are:

 * `__init__` for creating new objects
 * `__str__` for `str(...)`
 * `__repr__` for `repr(...)`

Comparison operators:

 * `__gt__` for `>`: **g**reather **t**han
 * `__lt__` for `<`: **l**ess **t**han
 * `__ge__` for `>=`: **g**reater than or **e**qual to
 * `__le__` for `<=`: **l**ess than or **e**qual to
 * `__eq__` for `==`: **eq**ual to
 * `__ne__` for `!=`: **n**ot **e**qual to

Other features:

 * `__hash__` for computing an objects hash number
 * `__len__` for `len(...)`
 * `__iter__` and `__next__` for `for x in my_object`
 * `__setattr__` for `my_object.some_attribute = a_value`
 * `__getattr__` for `my_object.some_attribute`

## `NotImplemented` for rich comparison operators

When implementing comparison operators, it's important to reject `other` types which are not supported for comparison:
class Bill:
    def __init__(self, denomination):
        self.denomination = denomination
        
    def __eq__(self, other):
        if not isinstance(other, Bill):          # only compare to other Bill objects
            return NotImplemented                # for foreign types, return NotImplemented instead
        return self.denomination == other.denomination
a = Bill(50)
b = Bill(100)
c = Bill(50)
print(a == b)
print(a == c)
print(a == 50)   # Bill.__eq__ returns NotImplemented, which is coerced to meaning False
print(50 == a)   # int.__eq__ also does
**Important**: `NotImplemented` is a not an exception. You do **not** `raise NotImplemented`! You have to `return NotImplemented`.
## Hashing

Generally speaking, a hash is a short string or number that can easily be computed from a more complex object. In Python, hashes are integers.

 * Computing the hash of an object multiple times should always return the same number
 * Two objects that have the same hash *could* be equivalent, but they don't have to be (if it's just a hash collision: when two different objects accidentally have the same hash).
 * Two objects that are equivalent (`a == b`) *must* have the same hash.

Requirements for implementing `__hash__`:

 * `__hash__` must return an integer
 * `__eq__` must also be implemented
 * if two objects are equal (`==`), then the hash computed by `__hash__` should be the same

In practice, implementing `__hash__` typically means:
 * Implementing `__eq__`
 * Taking the same object attributes which determine equality, adding them all to a tuple and returning `hash(on_that_tuple)`

**Important:** All the attributes that go into the tuple to be hashed must also be hashable (i.e., immutable).

In the following example, ingredients is a dictionary. But still, the contents matter for the hash. So in that case, we first need to transform the dictionary into some hashable data structure when implementing `__hash__`:
class Recipe():
    def __init__(self, name, ingredients):
        self.name = name
        self.ingredients = ingredients

    def __str__(self):
        return f"A recipe for {self.name}"

    def __eq__(self, other):
        if not isinstance(other, Recipe):
            return NotImplemented 
        return self.ingredients == other.ingredients    # we don't care about the name of the recipe. Two recipies with the same ingredients are equivalent

    def __hash__(self):
        return hash(tuple(self.ingredients.items()))
        
i = {"Butter (grams)": 20, "Garlic, smashed (cloves)": 1, "Salt (tsp)": .25}
r1 = Recipe("Garlic butter", i)
r2 = Recipe("Allium spread", i)
print(r1 == r2)
print(hash(r1))
print(hash(r2))
However, hashes see much more widespread use than you might think.
### Example 1: checking file integrity

Hashes are an easy and convenient way to check whether a file is fully intact, or whether it has been changed somehow. Many file downloads ([such as the download for Windows 11](https://www.microsoft.com/en-us/software-download/windows11)) will advertise hashes for their files. After you download the file, you can compute its hash and compare it to the advertised hash. If it differs, it means your download got corrupted somehow.
### Example 2: storing passwords

Any decent web service will **not** actually store any passwords. At best, they will store hashes of passwords. This still enables user authentication, but it mitigates the impact of data leaks.

This first example illustrates the problem: When a user sets their password, it is stored in the "database" and if anyone ever gets access to the database, they will see all users' passwords in plain text! Since many people use the same password everywhere, this is a very, VERY bad technique.
# Bad! Stores passwords in plain text!

class UserDB:
    def __init__(self):
        self.users = {}

    def set_password(self, username, password):
        self.users[username] = password
    
    def login(self, username, password):
        if self.users[username] == password:
            print("Login successful")
        else:
            print("Invalid password")

db = UserDB()
db.set_password("bob89", "hunter2")
db.login("bob89", "pw")
db.login("bob89", "hunter2")
print(db.users)                     # passwords can be leaked easily!
This problem can be solved quite easily by only storing the hash of each password:

 1. The user sets their password on the website
 2. The password is hashed and only the hash is stored. The password is immediately forgotten
 3. When the user wants to log in, they enter their password, and we just check if it has the same hash as the one in the database

Because hash functions are generally non-reversible, it is not possible to determine the password (string) from a given hash.
# Better. Only hashes are stored:

class UserDB:
    def __init__(self):
        self.users = {}

    def set_password(self, username, password):
        self.users[username] = hash(password)
    
    def login(self, username, password):
        if self.users[username] == hash(password):
            print("Login successful")
        else:
            print("Invalid password")

db = UserDB()
db.set_password("bob89", "hunter2")
db.login("bob89", "pw")             # authentication still works correctly, because (almost all) wrong passwords have a different hash
db.login("bob89", "hunter2")        
print(db.users)                     # Password is not stored at all! Only hashes are stored.
Note that this is **not** enough in practice. That's because a nefarious attacker could easily generate hashes for millions of passwords. This is called a "rainbow table". Then, when they gain access to the database, they can compare their hashes to the existing ones and still reverse-engineer your personal password.
# generate a lookup table from hash to actual password:
def generate_rainbow_table():
    res = {}
    for pw in ["password", "admin", "hunter2", "password1", "querty"]:
        res[hash(pw)] = pw
    return res
# hack into the server and get the stored hash for bob89:
print(db.users)
rt = generate_rainbow_table()
print(rt[7558422558281044130])    # attacker can simply look up the hash in the rainbow table
Now, the attacker knows your password, even though the server only stored its hash! Now they can use your password on all the other website where you used the same password. This is only possible, because the attacker knows how the hash is computed. For this reason, hashes are typically "salted" on the server. In the simplest case, that could look like this:
class UserDB:
    def __init__(self, salt):
        self.salt = salt
        self.users = {}

    def set_password(self, username, password):
        self.users[username] = hash((password, self.salt))
    
    def login(self, username, password):
        if self.users[username] == hash((password, self.salt)):
            print("Login successful")
        else:
            print("Invalid password")

db = UserDB("secret_salt")
db.set_password("bob89", "hunter2")
db.login("bob89", "pw")             # authentication still works correctly, because the salt is applied both when saving and checking the password
db.login("bob89", "hunter2")        
print(db.users)                     # Password is not stored at all! Only hashes are stored.
try:
    print(rt[-1393476854987916374])
except KeyError:
    print("Hash for user bob89 not found")
This at least prevents the attacker from generating rainbow tables that work in many scenarios. If they were able to obtain the secret salt, then they could still generate the rainbow table. That's why there's another technique called "adding pepper"... which is out of scope for this lecture.

**Two important side-notes**:

 1. NEVER implement your own cryptography. Re-use [tried and tested libraries](https://docs.python.org/3/library/crypto.html). If you build applications that require user management, use an existing service or implementation.
 2. If it really matters, get a cryptograph expert to do things for you. Not every developer has to be a cryptography expert!
## Example 3: Blockchain ðŸ¤¢ and Crytpocurrencies ðŸ¤®

While blockchain has legitimate uses, traditional cryptocurrencies require "proof of work". Without getting into the details, all this "work" involves is computing millions of hashes until you, by pure chance, find one that has specific characteristics (typically a given number of leading `0`s). Here's an illustration of how that works: 
import hashlib
from time import time

def proof_of_work(difficulty):
    target = '0' * difficulty
    data = "Does-not-really-matter"
    nonce = 0
    start_time = time()

    # compute hashes over and over again until we luck out
    while True:
        # By adding nonce to the data, we generate a new hash each iteration
        test_string = f"{data}{nonce}"
        # Compute hash (here we use sha256, one of many standardised hash functions)
        hash_result = hashlib.sha256(test_string.encode()).hexdigest()
        # Check if the hash starts with the required number of zeroes
        if hash_result.startswith(target):
            print(f"""Found solution after {nonce} tries, spending {time() - start_time:.2f} seconds: "{test_string}" -> {hash_result}""")
            return # finally done with this nonsense
        nonce += 1

proof_of_work(2)   # easy
proof_of_work(6)   # hard
#proof_of_work(30) # burn the planet
What an insane waste of energy!
## `try` / `except` / `finally` / `else`

Just keep these things in mind:

 * It's better to except specific exeptions instead of using naked `except`.
 * When an `except` block triggers, the content of that block has nothing to do with the rest of the entire try/except construct. Any additional exceptions that happen there need to be caught separately.
try:
    print("trying...")
    raise ValueError
except ValueError:
    print("ValueError occured")
except IndexError:
    print("IndexError occured")
except:
    print("some other exception occurred")
else:
    print("no exceptions occured")
finally:
    print("finally always executes")
<p style="height:100px"></p>
<hr>
<p style="height:100px"></p>



# `type` vs `isinstance`

The `type` function will give you the exact type of an object. `isinstance` on the other hand will check the entire inheritance tree and will return `True` not only if the given object matches the given type exactly, but also if it is a subclass of the given type.

In the following example, `Sub` inherits from `Middle` and `Middle` inherits from `Topmost`:
class Topmost:
    pass

class Middle(Topmost):
    pass

class Sub(Middle):
    pass

s = Sub()
print(s)
As such, `type(x)` will give the exact type (`Sub`):
type(s)
But `isinstance` will return `True` for any type that the instance inherits from. So our `x`, which is of type `Sub` **also** inherits from `Middle` and `Topmost` eventually!
print(isinstance(s, Sub))
print(isinstance(s, Middle))
print(isinstance(s, Topmost))
print(isinstance(s, object))   # real top-most, as Topmost still inherits from object
print(isinstance(s, str))
As a matter of fact `Topmost` is *not* the topmost class that `Sub` inherits from. Because in reality, `Topmost`, like all custom classes, inherits from `object`:
isinstance(s, object)
isinstance("hello", str)
isinstance("hello", object)
Note how even functions inherit from `object`:
isinstance(logger_factory, object)
# Class attributes vs instance attributes

You know that classes are like "blueprints" to make concrete objects. When we create a new instance of an object, the object will have instance-specific members:
class Toyota:
    def __init__(self, model):
        self.model = model

    def honk(self):
        return f"HONK, I'm a {self.model} HONK"


t1 = Toyota("Yaris")                  # t1 is an *instance* of Toyota
print(t1.model)                       # t1 has a "model" attribute, which is specific to the instance t1 (it was set via self.model = model)
print(t1.honk())                      # t1 also supports the "honk" method
print(Toyota.honk(t1))                # honk is defined as a member of Toyota
print(isinstance(t1, Toyota))         # t1 is an object of type 'Toyota'
print(isinstance(Toyota, type))       # Toyota is an object of type 'type'
print(isinstance(t1, object))         # all types inherit from object eventually
print(isinstance(Toyota, object))
print(type(t1))
print(type(Toyota))
So `t1` is an instance of `Toyota` and we can see that it has a variety of attributes, including `model`, but also `honk` (and `__init__`, etc.):
dir(t1)
However, **classes are also objects**. So not only do *instances* of a class have members, so does the *class* itself. It does not have `model` an an attribute (because model is set on `self`, not `Toyota`), but it does show `honk`:
dir(Toyota)
And we can **also** add attributes to the class (which is just another object). Notice how `some_attribute` is at the same indentation level as all the methods.
class Toyota:
    
    some_attribute = "I'm an attribute of the Toyota class (NOT of an instance)"
    
    def __init__(self, model):
        self.model = model

    def honk(self):
        return f"HONK, I'm a {self.model} HONK"

print(Toyota.some_attribute)      # NOT set via self.some_attribute ... but set directly on the class itself
Now, when we reflect on the `Toyota` object, we can see that it has an additional attribute:
dir(Toyota)
This may look like something new, but should not come as a surprise. After all, *methods* (which sit at the same level as `some_attribute`) are also members of the *class*:
print(Toyota.some_attribute)
print(Toyota.__init__)
print(Toyota.honk)
So really, now that you know how functions are just regular objects, it's kind of obvious that you can not only specify methods (function attributes of class objects), but also other kinds of attributes, like a string: there is not much different between `some_attribute` and `__init__`, it's just that one is a string and one is a function, but they are both attributes of the `Toyota` class object. Note that just like with the method `honk`, the attribute `some_attribute` is also available both via the class itself (where it is actually defined), **and** through any specific instance of the class:
t1 = Toyota("Corolla")
print(Toyota.some_attribute)  # class attribute accessible via class
print(Toyota.honk(t1))        # class method accessible via class
print(t1.some_attribute)      # class attribute accessible via instance
print(t1.honk())              # class method accessible via instance (self implicitely added as first parameter)
The fact that we can store attributes as part of the class itself (rather than just individual instances) can come in handy. One particularly common use case is illustrated below. Imagine that every new Toyota instance should have a unique serial number. We can simply store a counter as a *class attribute* and increment it whenever a new instance is created:
class Toyota:
    serial_counter = 1
    def __init__(self, model):
        self.model = model
        self.serial_number = Toyota.serial_counter   # access the class attribute to set the instance attribute
        Toyota.serial_counter += 1                   # increment the class attribute by 1

    def drive(self):
        print("driving")

t1 = Toyota("Yaris")
t2 = Toyota("Yaris")
t3 = Toyota("Corolla")
t3.drive()
print(t1.serial_number)
print(t2.serial_number)
print(t3.serial_number)
Above, you can see that `self.serial_number` is an **instance attribute** while `Toyota.serial_counter` is a **class attribute**.
Note, however, that all *instances* of `Toyota` will also hold references to the *class* variable:
t1 = Toyota("Yaris")
t2 = Toyota("Yaris")
print(t1.serial_number)
print(t2.serial_number)
print(Toyota.serial_counter)
print(t1.serial_counter)
print(t2.serial_counter)
# Both instances and the class itself refer to the SAME class attribute! Toyta.serial_counter only exists once, while serial_number is set for each individual instance.
print(t1.serial_counter is t2.serial_counter is Toyota.serial_counter)
### Summarizing class attributes:

 * Classes are just objects, they can have attributes.
 * Methods are function attributes of a class, but you can add other kinds of attributes as well.
 * A class attribute only exists **once** as a member of the class itself.
 * All instances of the class will refer to the same class attribute. In contrast, instance attributes are set via `self.`.
 * A common use case that you should be able to replicate is a serial counter that is incremented with each instantiation of the class.
# Static methods

You know how each method of a class implicitly receives `self` as the first parameter?

The following class represents a temperature sensor that might be installed in some HVAC system or factory. In a real scenario, `measure` would measure the temperature of a room or device. The sensor data is stored in an attribute `self.measurements`. A method `fahrenheit_measurements` returns the measurements, but with each value converted to Fahrenheit. The code to convert Celsius to Fahrenheit has been moved to a dedicated method `c_to_f`.
from random import randrange

class TempSensor:
    def __init__(self):
        self.measurements = []

    def measure(self):
        self.measurements.append(randrange(-20, 50))        # in the real world, this would gather a temperature from a real sensor, here it's just a random value

    def __str__(self):
        return f"Sensor data: {self.measurements}"

    def fahrenheit_measurements(self):
        return [self.c_to_f(m) for m in self.measurements]

    def c_to_f(self, value):
        return value * 1.8 + 32                             # self is not referred to anywhere in the method body! Compare this to the other methods, where self is always used in some way.

s = TempSensor()
for _ in range(5):
    s.measure()         # records 5 random temperatures
print(s)
print(s.fahrenheit_measurements())
In the example above, notice how `c_to_f` is a method that **only depends on parameters passed to the method** (in this case, `value`), but **`self` is not used anywhere in the method body**

In such cases, where a method of a class does not require any knowledge of `self` and its attributes, we can annotate the method as being a `@staticmethod`:
from random import randrange

class TempSensor:
    def __init__(self):
        self.measurements = []

    def measure(self):
        self.measurements.append(randrange(-20, 50))

    def __str__(self):
        return f"Sensor data: {self.measurements}"

    def fahrenheit_measurements(self):
        return [self.c_to_f(m) for m in self.measurements]

    @staticmethod                                                # this method is "static", because it doesn't use 'self' anywhere in the method body. No need for the parameter.
    def c_to_f(value):                                           # a @staticmethod does NOT get self provided implicitely!
        return value * 1.8 + 32

s = TempSensor()
for _ in range(5):
    s.measure()
print(s)
print(s.fahrenheit_measurements())
print(TempSensor.__str__(s))                                     # regular methods require the first parameter to be the object (self).
print(TempSensor.c_to_f(0))                                      # static methods can be called without providing self!
print(s.c_to_f(0))                                               # you can call the static method on the object or the class; the result is the same.
You don't *have to* annotate methods that don't use `self` (and drop the `self` parameter). You could just ignore the `self` parameter if you don't need it. However, semnatically, `@staticmethod` communicates to other developers that the functionality in this method does not relate to any of the object's state (like here, any specific temperatures recorded). The method `c_to_f` is basically like a plain function, only that it "belongs" to the `TempSensor` class. You don't need to have a `TempSensor` instance to use it.
### Summarizing static methods:

 * A static method of a class does **not** take `self` as a parameter.
 * Static methods are annotated with `@staticmethod` (which does not need to be imported)
 * Static methods are typically isolated pieces of behavior that are not connected with the state (i.e., `self`) of the class.
 * A common use case is helper functions that just convert or otherwise process values, without knowing about individual state.
# Testing

If you're not familiar with testing, you probably just "tried" your code with different inputs to see (visually) if it appears to work correctly. Let's revisit the IP validator from the exercises and assume it were an interactive application:
class IPValidator:
    def run(self):
        while True:
            addr = input("Please enter an IP address and hit enter: ")
            if addr == "exit":
                return
            print(f"{addr} is valid: {self.is_valid(addr)}")                          # could also call IPValidator.is_valid

    @staticmethod    
    def is_valid(ip):
        octets = ip.split(".")
        return (sum([IPValidator.is_valid_octet(octet) for octet in octets]) == 4)    # self doesn't exist, so definitely must use IPValidator.is_valid_octet
        
    @staticmethod    
    def is_valid_octet(octet):
        if not 1 <= len(octet) <= 3:
            return False
        for char in octet:
            if not char.isdigit():
                return False
        return 0 <= int(octet) <= 255
    
v = IPValidator()
v.run()
Of course, you might recognize that you don't actually have to call run() to test this class. You could just try using the methods individually (like in the exercise):
class IPValidator:
    def run(self):
        while True:
            addr = input("Please enter an IP address and hit enter: ")
            if addr == "exit":
                return
            print(f"{addr} is valid: {self.is_valid(addr)}")

    @staticmethod    
    def is_valid(ip):
        octets = ip.split(".")
        return (sum([IPValidator.is_valid_octet(octet) for octet in octets]) == 4)
        
    @staticmethod    
    def is_valid_octet(octet):
        if not 1 <= len(octet) <= 3:
            return False
        for char in octet:
            if not char.isdigit():
                return False
        return 0 <= int(octet) <= 255

print(IPValidator.is_valid("127.0.0.1"))
print(IPValidator.is_valid("asdf"))
print(IPValidator.is_valid("127.0.0.1.100"))
But of course that gets more and more tedious with more test cases. So you might just compare each test case to the expected value instead, so that you'll see "all Trues" when running your code:
class IPValidator:
    @staticmethod    
    def is_valid(ip):
        octets = ip.split(".")
        return (sum([IPValidator.is_valid_octet(octet) for octet in octets]) == 4)
        
    @staticmethod    
    def is_valid_octet(octet):
        if not 1 <= len(octet) <= 3:
            return False
        for char in octet:
            if not char.isdigit():
                return False
        return 0 <= int(octet) <= 255

print(IPValidator.is_valid("127.0.0.1") == True)
print(IPValidator.is_valid("asdf") == False)
print(IPValidator.is_valid("127.0.0.1.100") == False)
But this still isn't very clear when you have many test cases and things go wrong. It would be nicer if we had a way to test our code that...

 * Clearly spells out what went wrong
 * Tells us where it went wrong

For this reason, we have "unit testing". Python ships with a `unittest` module that provides these kinds of services.

To implement a unit test, you...
 1. create a new class that inherits from `unittest.TestCase`.
 2. implement multiple methods, all taking no parameters (except `self`) and starting with `test` for their method name.
 3. test exactly **one** feature or behavior per test case. You may want to instantiate a new instance of the class you're testing every time.
 4. optionally provide a meaningful message for test failures
import unittest

class IPValidatorTests(unittest.TestCase):

    def test_home(self):
        v = IPValidator()
        self.assertTrue(v.is_valid("127.0.0.1"))         # valid

    def test_invalid_string(self):
        v = IPValidator()
        self.assertFalse(v.is_valid("asdf"))             # not an IP

    def test_five(self):
        v = IPValidator()
        self.assertFalse(v.is_valid("127.0.0.1.100"))    # one too many octets

unittest.main(argv=[''], verbosity=3, exit=False)        # these parameters are only here because of Jupyter Notebook. Normally, you could just do unittest.main()
Don't be confused by the red color of the output in Jupyter Notebook. All tests pass as indicated by "OK". We could add messages, if we wanted:
import unittest

class IPValidatorTests(unittest.TestCase):

    def test_home(self):
        v = IPValidator()
        self.assertTrue(v.is_valid("127.0.0.1"), "127.0.0.1 wrongly identified as invalid")

    def test_invalid_string(self):
        v = IPValidator()
        self.assertFalse(v.is_valid("asdf"), "random string 'asdf' identified as valid IP")

    def test_five(self):
        v = IPValidator()
        self.assertFalse(v.is_valid("127.0.0.1.100"), "127.0.0.1.100 wrongly identified as valid")

unittest.main(argv=[''], verbosity=3, exit=False) # these parameters are only here because of Jupyter Notebook. Normally, you could just do unittest.main()
So if we now provide a faulty implementation, we'll receive some additional error message:
class IPValidator:
    @staticmethod    
    def is_valid(ip):
        return True

import unittest

class IPValidatorTests(unittest.TestCase):

    def test_home(self):
        v = IPValidator()
        self.assertTrue(v.is_valid("127.0.0.1"), "127.0.0.1 wrongly identified as invalid")

    def test_invalid_string(self):
        v = IPValidator()
        self.assertFalse(v.is_valid("asdf"), "random string 'asdf' identified as valid IP")

    def test_five(self):
        v = IPValidator()
        self.assertFalse(v.is_valid("127.0.0.1.100"), "127.0.0.1.100 wrongly identified as valid")

unittest.main(argv=[''], verbosity=3, exit=False) # these parameters are only here because of Jupyter Notebook. Normally, you could just do unittest.main()

The messages are not usually necessary. However, what's nice about testing like this is that it's easy to read whether or not the code is working as expected. It tells you where and why a test failed and why.

The best thing about tests is that they can **prevent regressions**. A regression is when a feature that previously worked fine stops working correctly. This can actually happen very often when working on existing code. Say we want to improve our implementation by using the "more pythonic" `all` instead of `sum`. While `sum` calculates a sum of list elements, `all` just checks if each element is `True`. This seems right because we just want to check if each octet is valid. **But this misses the case where each ocetet is valid, but there aren't exactly 4 of them**:
class IPValidator:
    @staticmethod    
    def is_valid(ip):
        octets = ip.split(".")
      # return (sum([IPValidator.is_valid_octet(octet) for octet in octets]) == 4)
        return all(IPValidator.is_valid_octet(octet) for octet in octets)
        
    @staticmethod    
    def is_valid_octet(octet):
        if not 1 <= len(octet) <= 3:
            return False
        for char in octet:
            if not char.isdigit():
                return False
        return 0 <= int(octet) <= 255

import unittest
class IPValidatorTests(unittest.TestCase):
    def test_home(self):
        v = IPValidator()
        self.assertTrue(v.is_valid("127.0.0.1"))
        
    def test_invalid_string(self):
        v = IPValidator()
        self.assertFalse(v.is_valid("asdf"))
        
    def test_five(self):
        v = IPValidator()
        self.assertFalse(v.is_valid("127.0.0.1.100"), "127.0.0.1.100 wrongly identified as valid")     # This test case saves us from introducing a regression bug

unittest.main(argv=[''], verbosity=3, exit=False) 
You can also get creative and generate a lot more test cases programmatically, for example:
class IPValidator:
    @staticmethod    
    def is_valid(ip):
        octets = ip.split(".")
        return len(octets) == 4 and all(IPValidator.is_valid_octet(octet) for octet in octets)
        
    @staticmethod    
    def is_valid_octet(octet):
        if not 1 <= len(octet) <= 3:
            return False
        for char in octet:
            if not char.isdigit():
                return False
        return 0 <= int(octet) <= 255

import unittest
class IPValidatorTests(unittest.TestCase):
    def test_first_two_octets(self):
        v = IPValidator()
        for a in range(256):
            for b in range(256):
                    self.assertTrue(v.is_valid(f"{a}.{b}.0.255"))  # gets called over 65'000 times

unittest.main(argv=[''], verbosity=3, exit=False) 
In this example, this is almost not necessary. You're probably better off testing edge cases. However, in some scenarios, generating test values like this can make a lot of sense.
The `unittest` framework also supports a couple of additional features. For example, you can implement the `setUp` method to execute some code *before each test method is run*:
class IPValidator:
    @staticmethod    
    def is_valid(ip):
        octets = ip.split(".")
        return len(octets) == 4 and all(IPValidator.is_valid_octet(octet) for octet in octets)
        
    @staticmethod    
    def is_valid_octet(octet):
        if not 1 <= len(octet) <= 3:
            return False
        for char in octet:
            if not char.isdigit():
                return False
        return 0 <= int(octet) <= 255
        
import unittest
class IPValidatorTests(unittest.TestCase):

    def setUp(self):                     # the setUp function is called before each test method execution!
        self.v = IPValidator()
        
    def test_home(self):
        self.assertTrue(self.v.is_valid("127.0.0.1")) # now we refer to self.v
        
    def test_invalid_string(self):
        self.assertFalse(self.v.is_valid("asdf"))
        
    def test_five(self):
        self.assertFalse(self.v.is_valid("127.0.0.1.100"), "127.0.0.1.100 wrongly identified as valid") 

unittest.main(argv=[''], verbosity=3, exit=False)
There also exist `tearDown`, called after each test method ends, and also `setUpClass` and `tearDownClass`, which are executed before and after an entire test class is used.
### Assertion methods

In these examples, we only used `assertTrue`, but there are [many more assertion functions](https://docs.python.org/3/library/unittest.html#assert-methods).

| Assertion Method | Equivalent To | Since Python |
|-|-|-|
| `assertEqual(a, b)` | `a == b` | - |
| `assertNotEqual(a, b)` | `a != b` | - |
| `assertTrue(x)` | `bool(x) is True` | - |
| `assertFalse(x)` | `bool(x) is False` | - |
| `assertIs(a, b)` | `a is b` | 3.1 |
| `assertIsNot(a, b)` | `a is not b` | 3.1 |
| `assertIsNone(x)` | `x is None` | 3.1 |
| `assertIsNotNone(x)` | `x is not None` | 3.1 |
| `assertIn(a, b)` | `a in b` | 3.1 |
| `assertNotIn(a, b)` | `a not in b` | 3.1 |
| `assertIsInstance(a, b)` | `isinstance(a, b)` | 3.2 |
| `assertNotIsInstance(a, b)` | `not isinstance(a, b)` | 3.2 |
| `assertAlmostEqual(a, b)` | `round(a-b, 7) == 0` | - |
| `assertNotAlmostEqual(a, b)` | `round(a-b, 7) != 0` | - |
| `assertGreater(a, b)` | `a > b` | 3.1 |
| `assertGreaterEqual(a, b)` | `a >= b` | 3.1 |
| `assertLess(a, b)` | `a < b` | 3.1 |
| `assertLessEqual(a, b)` | `a <= b` | 3.1 |
| `assertRegex(s, r)` | `r.search(s)` | 3.1 |
| `assertNotRegex(s, r)` | `not r.search(s)` | 3.2 |
| `assertCountEqual(a, b)` | *a* and *b* have the same elements in the same number, regardless of their order | 3.2 |
Long story short:

 * When you've "tried" the same inputs to your function, the same clicks in your frontend, the same call to your backend, more than 5 times: write a unit test
 * Unit tests will **save** you time.
 * To write unit tests, create a class inheriting from `unittest.TestCase` and implement methods starting with `def test`
 * Each test method should test exactly one thing

You have several options how to run unittests for the exercises in your programming environment.

 1. Configure your IDE. Here, again it will be important to have the correct *working directory* (CWD) set to the folder that **contains** the `task` folder.
 1. On the command line, navigate to the folder containing `task` and then run one of these commands:

To run a specific test file:

 ```bash
 python -m unittest task/tests.py
 ```
 
 or if you add `unittest.main()` at the end of the test file, you can also run it as a module:
 
 ```bash
 python -m task.tests
 ```

To run all test files contained in the task folder:

 ```bash
 python -m unittest discover -v task
 ```
### A couple more testing terms

#### Test-Driven Development (TDD)

The idea to **first** implement tests, then write the actual implementation.

#### Black-box testing

When you do not have access to the implementation to see how it actually works, you're performing black-box testing. You only get to try the implementation, call the methods, etc., but you cannot see inside the implementation. This is common practice in large companies, where testers are responsible for testing, without caring about how the code is implemented.

If working with compiled code, where the source is not available, black-box testing may also be the only option.

#### White-box testing

More regular testing where you, the tester, can also read the actual implementation code.

#### Fuzz testing

In fuzz testing, values used to test the implementation may be generated (semi-)randomly, similarly to what we did in `IPValidatorTests.test_first_two_octets`

You will be practicing some of these in the exercises!### Final exam

 * The final exam in Info1 will not be on paper. It will be in a similar setting as the midterm (using BYOD, Inspera).
 * The exam does NOT take place at Messe Oerlikon. It will take place in two lecture halls, one at Irchel Campus, one at Center Campus.
 * Detailed information will be provided roughly 2 weeks before the exam.
 * The time and date are unchanged (Thursday, 19.12.2024 some time between 11:30 and 14:30)

### ACCESS

 * The "Movies" task is not a good task. The total points for bonus calculations will certainly be adjusted down by at least these 3 points.
 * Performance should be better now. Further updates may be soon forthcoming
 * The deadline for assignment 7 has been extended until Friday at midnight.
# Recap from last week
### Class attributes

 * Classes are just objects, they can have attributes.
 * Methods are function attributes of a class, but you can add other kinds of attributes as well, like strings or numbers, or anything else.
 * A class attribute only exists **once** as a member of the class itself.
 * All instances of the class will refer to the same class attribute. In contrast, instance attributes are set via `self.`.
 * A common use case that you should be able to replicate is a serial counter that is incremented with each instantiation of the class.
class Toyota:
    
    serial_counter = 1
    
    def __init__(self, model):
        self.model = model
        self.serial_number = Toyota.serial_counter   # access the class attribute to set the instance attribute
        Toyota.serial_counter += 1                   # increment the class attribute by 1

    def drive(self):
        print("driving")

t1 = Toyota("Yaris")
t2 = Toyota("Yaris")
t3 = Toyota("Corolla")
t3.drive()
print(t1.serial_number)
print(t2.serial_number)
print(t3.serial_number)
print(t3.serial_counter)
print(Toyota.serial_counter)
### Static Methods

 * A static method of a class does **not** take `self` as a parameter.
 * Static methods are annotated with `@staticmethod` (which does not need to be imported)
 * Static methods are typically isolated pieces of behavior that are not connected with the state (i.e., `self`) of the class.
 * A common use case is helper functions that just convert or otherwise process values, without knowing about individual state.
 * In essence, static methods are just regular functions that happen to be placed inside a class definition.
from random import randrange

class TempSensor:
    def __init__(self):
        self.measurements = []

    def measure(self):
        self.measurements.append(randrange(-20, 50))

    def __str__(self):
        return f"Sensor data: {self.measurements}"

    def fahrenheit_measurements(self):
        return [self.c_to_f(m) for m in self.measurements]

    @staticmethod                                                # this method is "static", because it doesn't use 'self' anywhere in the method body. No need for the parameter.
    def c_to_f(value):                                           # a @staticmethod does NOT get self provided implicitely!
        return value * 1.8 + 32

s = TempSensor()
for _ in range(5):
    s.measure()
print(str(s))
print(s.fahrenheit_measurements())
print(TempSensor.__str__(s))                                     # regular methods require the first parameter to be the object (self).
print(TempSensor.c_to_f(0))                                      # static methods can be called without providing self!
print(s.c_to_f(0))                                               # you can call the static method on the object or the class; the result is the same.
### Testing

 * To implement a test, inherit from `unittest.TestCase` and implement a method which starts with the letters `test` for each thing you want to test.
 * One test should check one specific thing
 * Make use of the different [assertion functions](https://docs.python.org/3/library/unittest.html#assert-methods), instead of just using `assertTrue`.
def add_one(x):
    return x + 1

import unittest

class TestAddOne(unittest.TestCase):
    def test_basic(self):
        self.assertEqual(add_one(5), 6)
        
unittest.main(argv=[''], verbosity=3, exit=False) 
<p style="height:100px"></p>
<hr>
<p style="height:100px"></p>


# Type hints

You've learned that in Python, you do not need to specify the type of a variable. This is called *weak typing*, as opposed to *strong typing*, where variables must have a specific type. Here are a few examples for strongly typed languages:

**Java**
```java
public float addNumbers(float a, float b) {
    return a + b;
}
public double addNumbers(double a, double b) {
    return a + b;
}
```

**Kotlin**
```kotlin
fun addNumbers(a: Float, b: Float): Float = a + b
```

**C++**
```c
float addNumbers(float a, float b) {
    return a + b;
}
```

**Haskell** 
```haskell
addNumbers :: Float -> Float -> Float
addNumbers a b = a + b
```

**Rust**
```rust
fn add_numbers(a: f32, b: f32) -> f32 {
    a + b
}
fn add_numbers(a: f64, b: f64) -> f64 {
    a + b
}
```
whereas in Python, we might just write the following without mentioning types:
def add_numbers(a, b):
    return a + b
That's OK, but it often makes sense to communicate to other programmers (or even your future self) which types your code expects. Python supports this via the use of *type hints*:
def add_numbers(a: float, b: float) -> float:
    return a + b
As you can see, one can annotate variables and parameters with `: the_type` to specify the expected types, and functions with `-> the_type` to indicate the return type.

Note that in Python, **type hints are documentation only**. While there exist tools that can analyze your code and identify incompatible type hints, Python doesn't care at all:
def add_numbers(a: float, b: float) -> float:
    return a + b

s: float = add_numbers("Hello, ", "World!")          # works just fine, Python doesn't care about the type hints!
print(s)
This is quite unusual. In most programming languages, the compiler or intepreter will be able to recognize and warn when types do not match.

Use type hints at your leisure. You will not be required to use type hints in the exam, but you should recognize what they are.
# Recursion

[Did you mean: recursion?](https://www.google.com/search?hl=en&q=recursion)

With recursion, **a whole can be broken up into smaller pieces which resemble the whole**.

<img src="matryoshka.webp" width=200/><img src="fractal.webp" width=200/> <img src="check.webp" width=280/>


Recursion also occurs naturally in langauge, when a *part of a sentence* could *form its own sentence*. Parts of the following stentence are valid sentences by themselves:

 * "Alice thinks that Bob suspects that Charlie said that Dave believes that Eve wrote the code.":
   * "Bob suspects that Charlie said that Dave believes that Eve wrote the code."
     * "Charlie said that Dave believes that Eve wrote the code." 
       * "Dave believes believes that Eve wrote the code."
         * "Eve wrote the code."

For programming, there exist two broad and overlapping categories of how recursion plays a role:

 1. Recursive data structures
 2. Recursive algorithms
# Recursive Data Structures

Recursive data structures are ubiquitous, particularily in the form of trees or graphs.

Files and Folders on a computer form a file tree, where every sub-tree is itself a file tree. No matter where in the tree you are, you have the same situations: there may be files and sub-folders.
```

WINDOWS
â””â”€â”€ C:
    â”œâ”€â”€ Program Files/
    â”œâ”€â”€ Documents and Settings/
    â”‚   â””â”€â”€ User/
    â”‚       â”œâ”€â”€ Office Document.odt
    â”‚       â””â”€â”€ files.txt
    â”œâ”€â”€ Windows/
    â””â”€â”€ System32/
MAC OSX
â””â”€â”€ /
    â”œâ”€â”€ Applications/
    â”œâ”€â”€ System/
    â”‚   â””â”€â”€ Users/
    â”‚     â””â”€â”€ username/
    â”œâ”€â”€ Office Document.odt
    â””â”€â”€ Foto.png
LINUX
â””â”€â”€ /
    â”œâ”€â”€ bin/
    â”œâ”€â”€ dev/
    â”œâ”€â”€ etc/
    â”œâ”€â”€ home/
    â”‚   â””â”€â”€ username/
    â”‚       â”œâ”€â”€ Office Document.odt
    â”‚       â””â”€â”€ Foto.png
    â””â”€â”€ usr/
```

In graphs, you can 'recurse' from node to node (possibly forever, if travelling along cycles). Wherever in the graph you are, the basic conditions are the same (you have a value and a number of outgoing connections).

<div>
<img src="social.png" width="600"/>
</div>

Python source code itself represented as a recursive data structure. Expressions can contain sub-expressions, which contain sub-expressions, etc.:

<div>
<img src="expression_tree.png" width="500"/>
</div> 
One of the simplest recursive data structures is the humble list: any part of a list **is itself a list**! Parts of lists are "self-similar":
l = [0, 1, 2, 3, 4, 5]

# Any part of a list is itself a list:
print(l[1:])
print(l[1:])
print(l[:-2])
print(l[2:3])
Even what comes *before or after* the first or last element is still a list. It just happens to be the *empty list*:
print(l[6:])
To prove this:
print(l + [] == l)
print([0, 1, 2, 3, 4, 5] + [] == [] + [0, 1, 2, 3, 4, 5] + [])
That means that clearly lists can be considered to be recursive data structures. In this case, **a whole can be broken up into smaller pieces which resemble the whole**, manifests itself as **a list can be broken up into smaller pieces, which themselves are lists**.

Now imagine Python didn't have lists. How could we implement a `List` datatype without using tuples or lists, or any other pre-existing data structure? Using recursion, of course!

We ask the question: "What is a list?"
The "normal" answer might be something like "A list is an ordered sequence of values". But we could also answer:

"A list is some *value* followed by either A) another *list* or B) *nothing*"
class List:
    def __init__(self, value, rest = None):             # rest can either be A) another List or B) None
        self.value = value
        self.rest = rest

    def __str__(self):
        return f"{self.value}" + (f", {self.rest}" if self.rest else "")

l = List(1, List(2, List(3)))
print(l)
This kind of list implementation is called a **linked list**. In our `List` implementation, each instance holds a `value`, and a *reference* to the `rest` of the list, which is just another `List` instance, until the last element, where `rest` is `None`:

<div>
<img src="linked_l1.png" width="700"/>
</div> 

This may seem unintuitive, but it's really possible to implement a fully working list without using any sequences, just references and recursion. Here's how addition could be implemented:
class List:
    def __init__(self, value, rest = None):
        self.value = value
        self.rest = rest

    def __str__(self):
        return f"{self.value}" + (f", {self.rest}" if self.rest else "")

    def __add__(self, other):               # determines what happens when the + operator is used
        if self.rest == None:               # if this is the last element, rest (which was None) now becomes other
            self.rest = other
            return self
        else:                               # otherwise, add other to rest
            self.rest = self.rest + other   # recursive call to List.__add__
            return self

l1 = List(1, List(2, List(3)))
l2 = List(4, List(5))
res = l1 + l2
print(res)
<div>
<img src="linked_add.png" width="800"/>
</div> 
 
We could add type hints to make things clearer. To be clear, `value` really can be any type, not just a number:
from typing import Any
from __future__ import annotations

class List:
    def __init__(self, value: Any, rest: List | None = None):               # rest can be of type List or it can be a None instance. By default it is None
        self.value: Any = value
        self.rest: List | None = rest
        
    def __str__(self):
        return f"{self.value}" + (f", {self.rest}" if self.rest else "")

    def __add__(self, other: List):
        if self.rest == None:
            self.rest = other
            return self
        else:
            self.rest = self.rest + other
            return self


l1 = List(1, List("hello", List(3)))
l2 = List(4, List(print))
res = l1 + l2
print(res)
Using UML, we could draw `List` as follows. Each `rest` is either 0 or 1 elements of the `List` type:

<div>
<img src="linked_list.png" width="500"/>
</div>
<span style="color:purple;font-weight:bold">Exercise</span>

Implement `List.__len__`, so that calling `len` on a list will determine the `List`s real total length. To accomplish this, again think about lists recursively. The thinking might go like this:

 1. A list consits of a value and the rest, which is either another list or nothing
 2. That means a list by itself has length 1, plus whatever length the rest is (0 if there is no rest)
 3. How do you figure out the length of the rest? Well the rest is just another list, so you can call `len` on it.
class List:
    def __init__(self, value, rest = None):
        self.value = value
        self.rest = rest

    def __str__(self):
        return f"{self.value}" + (f", {self.rest}" if self.rest else "")

    def __len__(self):
        pass # Implement this
        
l1 = List(1, List(2, List(3, List(4, List(5)))))
#len(l1)
Notice that in this implementation, each element only knows its recursive (following) neighbor, but not its parent (or preceding) element. There is also a "doubly linked list", where each node holds a reference both to the following and the preceeding item.

While you will not need to create your own list implementation, tree structures are quite common. Here is a basic *binary tree* implementation. A binary tree is a tree-like data structure where each element has two child elements (which can be either another tree, or nothing):
class Binary:
    def __init__(self, value, left = None, right = None):
        self.value = value
        self.left = left
        self.right = right

    def __str__(self):
        return f"{self.value}\nLeft: {self.left}\nRight: {self.right}"

b = Binary(1,                            # left and right are Binary
           Binary(10,                    # left and right are Binary
                  Binary(100),           # left and right are None
                  Binary(101),           # left and right are None
                 ),
           Binary(20,                    # left and right are Binary
                  Binary(200,            # right is None
                        Binary(2000)),   # left and right are None
                  Binary(300,            # left is None
                        None,
                        Binary(3000)),   # left and right are None
                 )
          )
<div>
<img src="binary.png" width="1200"/>
</div>
Again, we could implement all kinds of functionality based on this structure. For example, let's say this binary tree will only contain numbers, so we can -- for any node in the tree -- sum it's total value (adding up all values in all descendants of the tree):

<span style="color:purple;font-weight:bold">Exercise</span>

Implement `Binary.sum`, which adds up all numbers in the given tree, recursively. To accomplish this, the thinking might go like this:

 1. A binary tree node consits of a value and two branches, which are either another tree node or nothing
 2. So the total to be calculated for a tree node is its own value, plus the sum of each branch (or 0 if there is no branch)
 3. How do you figure out the sum of each branch? Well the branch is just another binary tree node, so you can call `sum` on it.
class Binary:
    def __init__(self, value, left = None, right = None):
        self.value = value
        self.left = left
        self.right = right

    def __str__(self):
        return f"{self.value}\nLeft: {self.left}\nRight: {self.right}"\

    def sum(self):
        pass # Implement this
            

b = Binary(1,
           Binary(10,
                  Binary(100),
                  Binary(101),
                 ),
           Binary(20,
                  Binary(200,
                        Binary(2000)),
                  Binary(300,
                        None,
                        Binary(3000)),
                 )
          )

print(b.sum())
Indeed, we looked at a tree-like, recursive data structure a few weeks ago. A `Folder` is a recursive data type, because it can contain other `Folder`s (along side other `File`s as well). Here's a similar example with some adjustments compared to the previous version. In particular, we added a method `list`, which determines how a `File` (meaning `TextFile` or `Folder`) is represented in a directory tree.
from abc import ABC, abstractmethod

class File(ABC):
    def __init__(self, filename):
        self.filename = filename

    @abstractmethod
    def get_size(self):
        pass

    def __str__(self):
        return f"{self.filename} ({self.get_size()})"

    def list(self, level=1):                                   # Determines what a File looks like in a directory listing
        return self.__str__()                                  # By default, any inheriting class will simply use __str__ for this

class TextFile(File):                                          # For example, TextFile doesn't override the list method, it inherits File.list
    def __init__(self, filename, text=""):
        super().__init__(filename)
        self.text = text

    def get_size(self):
        return len(self.text)

class Folder(File):
    def __init__(self, filename, content=None):                # Remember that default values should be immutable! Don't use a list here!
        super().__init__(filename)
        self.content = content if content != None else []      # Create an empty list if content was not provided

    def get_size(self):
        return sum(c.get_size() for c in self.content)
        
    def __str__(self):                                         # calling str() on a Folder will list its contents
        return self.list()

    def list(self, level=1):
        return f"{super().__str__()}\n{"\n".join([f"{level * ' ' * 2}- {c.list(level=level+1)}" for c in self.content])}"

root = Folder('C:\\')
users = Folder('Users')
root.content.append(users)

m = Folder("My Documents", [                                   # We can construct entire sub-trees with a single constructor
  TextFile("empty.txt"),
  TextFile("passwords.txt", "bob84: hunter2"),
  Folder("Recipes", [                                          # and also add nested Folders this way
    TextFile("pico_de_gallo.txt", "..."),
    TextFile("breads.txt", "..."),
  ]),
  TextFile("five.txt", "12345"),
])
users.content.append(m)

shopping = TextFile("shopping.txt", "tomatoes, lime, coriander")
m.content.append(shopping)

print(shopping)                                                # we can still call str() on both files and folders
print(root)
In this example, the return value of `list` is constructed **recursively**. Each folder calls

```python
c.list(level=level+1)
```

for each file it contains. If that file is just a `TextFile`, and `TextFile.list` is called, then the inherited implementation `File.list` is used. If that file is another `Folder`, another listing is generated.
### What to remember:

 * A recursive data structure can reference ("contain") elements of the same type as itself. Examples:
   * A binary tree can reference other binary trees
   * A linked list refers to another linked list
   * A folder can contain more folders
   * A company can be organized into different units, which can contain sub-departments and further sub-divisions, each with a manager and employees
   * Python code, where each expression can contain subexpressions, forming an expression tree
 * When operating on recursive data structures, it is often necessary to recursively call the same method (see `List.__len__`, `Folder.list`, `BinaryTree.sum`: they all call the same method on their referenced elements / descendants)
 * There is often a recognizable **THIS and then the REST** pattern


# Recursive Algorithms

Some mathematical and programmatic problems can be expressed recursively.

## Fibonacci

One famous example is the Fibonnachi sequence:

<div>
<img src="fib.png" width="500"/>
</div>

The sequence starts with the numbers `1` and `1`, which add up to `2` (you could start at `0 + 1 = 1` but not today). Then, for each follow-up step, the last two numbers are added up:

```
1 + 1 = 2        # 3rd Fibonacci number
1 + 2 = 3        # 4th Fibonacci number
2 + 3 = 5        # 5th Fibonacci number
3 + 5 = 8        # 6th Fibonacci number
5 + 8 = 13       # 7th Fibonacci number
8 + 13 = 21      # 8th Fibonacci number
13 + 21 = 34     # 9th Fibonacci number
21 + 34 = 55     # 10th Fibonacci number
34 + 55 = 89     # 11th Fibonacci number
55 + 89 = 144    # 12th Fibonacci number
...
```

This means that the Fibonacci number `n` is the sum of the Fibonacci numbers `n-1` and `n-2`. For example, the 6th Fibonacci number is the sum of the 4th and 5th Fibonacci numbers:

`fib(6) = fib(5) + fib(4) = 5 + 3 = 8`

<div>
<img src="fib_tree.png" width="300"/>
</div> 


We could implement an iterative way to compute the n'th Fibonacci number like this:
def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b     # a becomes b, b becomes a + b
    return a

print(fib(6))
This isn't particularily easy to read and understand. On the other hand, a recursive solution jumps right out of the definition.

When writing this recursive solution, the question we ask is less "**How do** we calculate the fibonacci number *n*", and more "**What is** the fibonacci number *n*".
def fib(n):
    if n <= 1:                          # base case: if n <= 1, return n
        return n
    return fib(n - 1) + fib(n - 2)      # general case: fib(n) = fib(n-1) + fib(n-2)
print(fib(6))
<div>
<img src="fib6_recursive.png" width="1200"/>
</div> 
Notice, however, that this isn't a particularily efficient solution (in Python): many values are computed multiple times. For example, `fib(2)` is calculated 5 times! But don't be bothered by this. Computers are fast. If a recursive solution is more elegant. and more easy to understand, and not impacting any real-world performance, then by all means, go for it. Also, functional languages may employ *memoization*, where an expression such as `fib(2)` would only be computed the first time, with subsequent calls of the function simply returning a cached (memoized) value.

Let's see a few more examples.
### Factorials

Consider the problem of calculating the factorial of a number. Factorial, denoted by `n!`, is the product of all positive integers from 1 to `n`. For example, `4!` (read as "4 factorial") is calculated as follows: $4! = 4 \times 3 \times 2 \times 1 = 24$. `f(n)` as a mathematical function that calculates the factorial: $f: n \rightarrow n!$

Now, let's manually unfold this function using the defined signature $f: n \rightarrow n!$ to understand how it computes the factorial of 4:

Let's unfold `f(4)` to see all the recursive calls and the smaller factorial problems:

```shell
f(4) = 4 * f(3)
           f(3) = 3 * f(2)
                      f(2) = 2 * f(1)
                                 f(1) = 1 * f(0)
                                            f(0) = 1 
```

So, `f(4)` recursively calls `f(3)`, which calls `f(2)`, which calls `f(1)`, which calls `f(0)`. Each of these calls contributes to the final result:

1. `f(0)` is evaluated and passed to `f(1)`:
    ```shell
    f(4) = 4 * f(3)
               f(3) = 3 * f(2)
                          f(2) = 2 * f(1)
                                     f(1) = 1 * 1
    ```
    
2. `f(1)` can now be evaluated and passed to `f(2)`:
    ```shell
    f(4) = 4 * f(3)
               f(3) = 3 * f(2)
                          f(2) = 2 * 1
    ```
    
3. `f(2)` can now be evaluated and passed to `f(3)`:
    ```shell
    f(4) = 4 * f(3)
               f(3) = 3 * 2
    ```
    
4. `f(3)` can now be evaluated and passed to `f(4)`:
    ```shell
    f(4) = 4 * 6
    ```
    
5. `f(4)` can now be evaluated:
    ```shell
    f(4) = 24
    ```

Therefore, `f(4) = 4! = 24`, matching the result we obtained earlier.

Notice how `f` first unfolds/chains a number of recursive calls (`f(3)`, `f(2)`, `f(1)`) until a **base case** `f(0)`, and later evaluates these from the last call:
```shell
f(4)
= 4 * f(3)
= 4 * (3 * f(2))
= 4 * (3 * (2 * f(1)))
= 4 * (3 * (2 * (1 * f(0))))
= 4 * (3 * (2 * (1 * 1)))
= 4 * (3 * (2 * 1))
= 4 * (3 * 2))
= 4 * 6
= 24
```

The definition of `f` consists of two logical components:

1. **Base Case for `f(0)`:** We define the factorial of 0 as 1. This is the simplest case, where we don't need to perform any further recursion. It serves as the termination condition.

   $f: 0 \rightarrow 1$
   
3. **Recursive Case:** For any positive integer `x`, we calculate `f(x)` by multiplying `x` with the result of `f(x - 1)`. This recursive step reduces the problem to a smaller subproblem, gradually reaching the base case.

   $f: x \rightarrow x \times f(x - 1)$
In Python, we can implement the formal definition of `f` as follows:
def factorial(n):
    if n == 0:
        return 1                     # Base case: f(0) is defined as 1
    else:
        return n * factorial(n - 1)  # Recursive case: f(n) = n * f(n-1)

print(f"factorial({4}) = {factorial(4)}")
We can confirm that `factorial` unfolds as the formal definition of `f` by adding some debugging logic
def factorial_debug(n):
    if n == 0:
        print(f"f({n}) = 1")
        return 1                             # Base case: f(0) is defined as 1
    else:
        print(f"f({n}) = {n} * f({n - 1})")
        return n * factorial_debug(n - 1)    # Recursive case: f(n) = n * f(n-1)
print(f"f({4}) = {factorial_debug(4)}")
Although recursion is an elegant way to solve factorial problems, we can also implement it iteratively.
The `factorial_iterative` function calculates the factorial by iteratively multiplying the integers from 1 to `n`
def factorial_iterative(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result
print(f"f({4}) = {factorial_iterative(4)}")
## Basic Concepts of Recursive Computation

### Key Concepts of Recursion

Recursion involves several key concepts:

1. **Base Case:** Every recursive problem must have a base case. This is the simplest instance of the problem that can be solved directly without further recursion. It serves as the stopping condition.
2. **Recursive Case:** In the recursive case, a function calls itself with modified input to solve a slightly smaller sub-problem. The recursive case reduces the problem toward the base case.
3. **Scopes:** Every recursive function call gives rise to a new scope, preserving the local variables' context. This mechanism enables the program to maintain and revisit the function's state as needed when the function concludes its execution.

### Advantages of Recursion

Why should we use recursion? Recursion offers several advantages:

1. **Elegant Solutions:** Recursion often leads to elegant and concise solutions for complex problems. It simplifies code by breaking it into manageable pieces.
2. **Divide and Conquer:** It is a natural fit for problems that can be divided into smaller, similar sub-problems. This "divide and conquer" approach can be more efficient.
3. **Abstraction:** Recursion allows us to abstract complex problems into simple function calls, making code more understandable and maintainable.

### Disadvantages and Pitfalls

While recursion is a powerful tool, it's not always the best choice:

1. **Performance:** Recursive functions can be less efficient due to the overhead of function calls and stack management. For some problems, iterative solutions may be faster.
2. **Stack Overflow:** Recursion can lead to a stack overflow error if not carefully managed. It's essential to ensure that the base case is reachable and that the problem size reduces with each recursive call.

## The Three Steps of Recursion

Solving a problem recursively usually involes three steps:


### Step 1: Base Cases
The first step is having a **base case**. The base case is the simplest (trivial) instance of the problem that **can be solved directly without further recursion**. It serves as the termination condition, preventing infinite recursion. In the case of the factorial example, this is $f: 0 \rightarrow 1$. Without base cases, recursion would become an endless loop without progress. There can be more than one base case in the code for different termination conditions.

Let's take the classic factorial problem as an example. The base case for calculating the factorial of 0 is defined as 1. This is the simplest instance, and it allows us to stop the recursion. If we don't have a base case, the recursion continues indefinitely:
def factorial_no_base_case(n):
    print(f"f({n}) = {n} * f({n - 1})")
    return n * factorial_no_base_case(n - 1)
import sys
sys.setrecursionlimit(50)                     # for demo purposes we temporarily set Python's recursion limit to 50 calls. The default is 1000.

print(f"factorial_no_base_case(4) = ")
try:
   factorial_no_base_case(4)
except RecursionError as e:                   # 'as e' obtains the Exception object that was raised into a variable 'e'
    print(f"RecursionError: '{e}'")

sys.setrecursionlimit(1000)
Thus, you must always first make sure you know that the **base case** is going to be!
### Step 2: Recursive Cases

The second step is to **break up** the problem, usually by taking one piece of the problem (for example the current element, the current number, etc.) and calling the function recursively on the rest of the problem.

In the factorial problem, breaking up the problem means taking `n` and breaking off the rest of the problem into a recursive call `f(n-1)`. There could again be multiple recursive calls. This is, for example, true for the `BinaryTree` from earlier:

```python
class Binary:
    def __init__(self, value, left = None, right = None):
        self.value = value
        self.left = left
        self.right = right

    def __str__(self):
        return f"{self.value}\nLeft: {self.left}\nRight: {self.right}"\

    def sum(self):
        return (self.value + 
                (self.left.sum() if self.left else 0) +         # recursive case #1 and base case #1
                (self.right.sum() if self.right else 0)         # recursive case #2 and base case #2
               )
```
### Step 3: Combine Solutions
The third step of recursion is to **combine solutions**. In this step, we utilize the results of smaller sub-problems to build the solution for the original problem. As we return from recursive calls, we combine the solutions to construct the final answer. This step unifies the results from different parts of the problem to create the whole solution.

In the factorial problem, we multiply results of the recursive cases. Each recursive call contributes to the final product, and this combination leads to the solution.
## Translating Iterative Functions into Recursive Functions: Examples

For most recursive functions there exists a recursive variant, let's look at some examples
### Example: Fibonacci Sequence
Calculate the nth term of the Fibonacci sequence.
def iterative_fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a
def recursive_fibonacci(n):
    if n <= 1:
        return n
    return recursive_fibonacci(n - 1) + recursive_fibonacci(n - 2)
print(f"iterative_fibonacci(7) = {iterative_fibonacci(7)}")
print(f"recursive_fibonacci(7) = {recursive_fibonacci(7)}")
### Example: Sum of Numbers
This function calculates the sum of numbers from 1 to a given positive integer n.
def iterative_sum(n):
    result = 0
    for i in range(1, n + 1):
        result += i
    return result
def recursive_sum(n):
    pass # Implement this
print(f"iterative_sum(5) = {iterative_sum(5)}")
print(f"recursive_sum(5) = {recursive_sum(5)}")
### Example: Powers Calculation
This function calculates the result of raising a base number to a given exponent using repeated multiplication.
def iterative_power(base, exponent):
    result = 1
    for _ in range(exponent):
        result *= base
    return result
def recursive_power(base, exponent):
    pass # Implement this
print(f"iterative_power(2, 3) = {iterative_power(2, 3)}")
print(f"recursive_power(2, 3) = {recursive_power(2, 3)}")
### Example: List Summation
This function calculates the sum of all elements in a list.
def iterative_list_sum(arr):
    result = 0
    for num in arr:
        result += num
    return result
def recursive_list_sum(arr):
    pass # Implement this
print(f"iterative_list_sum([1, 2, 3, 4, 5]) = {iterative_list_sum([1, 2, 3, 4, 5])}")
print(f"recursive_list_sum([1, 2, 3, 4, 5]) = {recursive_list_sum([1, 2, 3, 4, 5])}")
### Example: List Length
This function calculates the length of a list.
def iterative_list_length(arr):
    length = 0
    for _ in arr:
        length += 1
    return length
def recursive_list_length(arr):
    pass # Implement this
print(f"iterative_list_length([10, 20, 30, 40, 50]) = {iterative_list_length([10, 20, 30, 40, 50])}")
print(f"recursive_list_length([10, 20, 30, 40, 50]) = {recursive_list_length([10, 20, 30, 40, 50])}")
### Example: List Reversal
This function reverses the order of elements in a list.
def iterative_list_reverse(arr):
    reversed_list = []
    for i in range(len(arr) - 1, -1, -1):
        reversed_list.append(arr[i])
    return reversed_list

    # Pythonic Alternative:
    # return arr[::-1]
def recursive_list_reverse(arr):
    pass # Implement this
print(f"iterative_list_reverse([1, 2, 3, 4, 5]) = {iterative_list_reverse([1, 2, 3, 4, 5])}")
print(f"recursive_list_reverse([1, 2, 3, 4, 5]) = {recursive_list_reverse([1, 2, 3, 4, 5])}")
## Tail Recursion

A recursive function is *tail recursive* if there is no suspended computation in the evaluation stack as the function unfolds. In simpler terms, it's tail recursion if the *last thing that happens in the function is the recursive call*.

Some languages employ compilers or interpreters that can optimize (unfold) tail-recursive functions such that a deeply nested recursive call won't create a whole stack of frames. On the other hand, non-tail-recursive implementations may lack performance, potentially leading to a growing stack and increased risk of stack overflow, necessitating consideration of alternative approaches for deep recursion scenarios. However, Python does not optimize tail-recursive functions, so it makes no difference here.

In the example above, `recursive_list_reverse` is not tail recursive, because the addition (`+`) operation happens after the recursive call, so the recursive call is *not* the last thing that happens. The list reversal function can be implemented relying on tail recursion by updating the output value directly in the function argument. In this approach, an additional parameter, often named `accumulator`, is used to accumulate the reversed list.

When the function is called recursively, the accumulator is updated by adding the current element to the beginning of the reversed list. This function is now tail recursive, because the addition (`+`) happens before the recursive call, which is the last thing that happens.

This implementation works by progressively building the reversed list in the accumulator, effectively reversing the order of elements in the original list. It demonstrates an alternative recursive strategy that relies on tail recursion, providing insights into how the function's evaluation unfolds.
def recursive_list_reverse_tail(arr, reversed_list=None):
    if reversed_list is None:
        reversed_list = []
    if arr == []:
        return reversed_list
    return recursive_list_reverse_tail(arr[:-1], reversed_list + [arr[-1]])
print(f"recursive_list_reverse_tail([1, 2, 3, 4, 5]) = {recursive_list_reverse_tail([1, 2, 3, 4, 5])}")
### Example: String Reversal
This function reverses a string.
def iterative_string_reverse(s):
    return s[::-1]
def recursive_string_reverse(s):
    pass # Implement this
print(f'iterative_string_reverse("Hello World!") = {iterative_string_reverse("Hello World!")}')
print(f'recursive_string_reverse("Hello World!") = {recursive_string_reverse("Hello World!")}')
def iterative_is_palindrome(s):
    return s == s[::-1]
def recursive_is_palindrome(s):
    if len(s) == 0:
        return True
    if s[0] != s[-1]:
        return False
    return recursive_is_palindrome(s[1:-1])
print(f'iterative_is_palindrome("radar") = {iterative_is_palindrome("radar")}')
print(f'recursive_is_palindrome("radar") = {recursive_is_palindrome("radar")}')
print(f'iterative_is_palindrome(["Hello", 2, True, True, 2, "Hello"]) = {iterative_is_palindrome(["Hello", 2, True, True, 2, "Hello"])}')
print(f'recursive_is_palindrome(["Hello", 2, True, True, 2, "Hello"]) = {recursive_is_palindrome(["Hello", 2, True, True, 2, "Hello"])}')
### Example: Character Removal
This function removes all occurrences of a character from a string.
def iterative_remove_character(s, char):
    return s.replace(char, "")
def recursive_remove_character(s, char):
    pass # Implement this
print(f'iterative_remove_character("Hello, World!", "l") = {iterative_remove_character("Hello, World!", "l")}')
print(f'recursive_remove_character("Hello, World!", "l") = {recursive_remove_character("Hello, World!", "l")}')
### Revisiting linked lists

Now that you know about the three steps in writing recursion, you can recognize the same patter being used when working with recursive data structures:

1. **Base Case**: if there is no `rest`, its length is `0`.
2. **Recursive case**: compute the length of `rest` via a recursive call to `List.__len__`.
3. **Combine Solutions**: Add the local problem (`1`) to the result of the recursive call.
class List:
    def __init__(self, value, rest = None):
        self.value = value
        self.rest = rest

    def __str__(self):
        return f"{self.value}" + (f", {self.rest}" if self.rest else "")

    def __len__(self):
        return 1 + (0 if not self.rest else len(self.rest))
        
l1 = List(1, List(2, List(3, List(4, List(5)))))
len(l1)
### Revisiting binary trees

The same pattern can be identified in the `BinaryTree`:

1. **Base Case #1**: if there is no `left`, its length is `0`. **Base Case #2**: if there is no `right`, its length is `0`.
2. **Recursive case #1**: compute the length of `left` via a recursive call to `Binary.sum`. 2. **Recursive case #2**: compute the length of `right` via a recursive call to `Binary.sum`.
3. **Combine Solutions**: Add the local problem (`value`) to the result of the two recursive calls.
class Binary:
    def __init__(self, value, left = None, right = None):
        self.value = value
        self.left = left
        self.right = right

    def __str__(self):
        return f"{self.value}\nLeft: {self.left}\nRight: {self.right}"\

    def sum(self):
        return (self.value + 
                (self.left.sum() if self.left else 0) +         # recursive case #1 and base case #1
                (self.right.sum() if self.right else 0)         # recursive case #2 and base case #2
               )
b = Binary(1,
           Binary(10,
                  Binary(100),
                  Binary(101),
                 ),
           Binary(20,
                  Binary(200,
                        Binary(2000)),
                  Binary(300,
                        None,
                        Binary(3000)),
                 )
          )

print(b.sum())
## Revisiting language

The steps of recursion even apply to our natural language example:

1. **Base Case**: "Eve wrote the code." - there are no further sub-sentences
2. **Recursive case**: Another full sentence
3. **Combine Solutions**: Connect sub-sentences using `that`

 * "Alice thinks that Bob suspects that Charlie said that Dave believes that Eve wrote the code.":
   * "Bob suspects that Charlie said that Dave believes that Eve wrote the code."
     * "Charlie said that Dave believes that Eve wrote the code." 
       * "Dave believes believes that Eve wrote the code."
         * "Eve wrote the code."
             # Final stretch

 * Today: some minor topics yet to be covered
 * Next week: Git
 * In two weeks: Last lecture, preparation for the exam

The exam is going to take place on **Thursday 19.12.2024** some time between 11:30 and 14:00. More information will follow.

Until then: practice, practice, practice!

# Supertab

In the lecture of 10.12.2024 (in two weeks), we will be testing Supertab in-class. **Participation is mandatory**, but you do not have to come physically: you may participate from home. Detailed instructions will follow next week and via Email.

# Important Notice 

Soon, you will **no longer be able to use SMS** for two-factor authentication (2FA) on edu-ID. If you're already using an authenticator app, then you're OK. But if you receive an SMS code when logging in, then you must change your authentication method now. Make sure you do this before your exams! More information:

[https://www.uzh.ch/blog/zi/2024/11/22/switch-edu-id-mit-zwei-faktor-authentifizierung-sms-option-faellt-weg/](https://www.uzh.ch/blog/zi/2024/11/22/switch-edu-id-mit-zwei-faktor-authentifizierung-sms-option-faellt-weg/)
## Recap: Recursion
With recursion, **a whole can be broken up into smaller pieces which resemble the whole**.

Here is how one might implement the functionality of getting the sum of a list `numbers` iteratively and recursively:
def iter_sum(numbers):
    res = 0
    for n in numbers:
        res += n
    return res

def rec_sum(numbers):
    if not numbers:
        return 0
    return numbers[0] + rec_sum(numbers[1:])           # the recursive call happens BEFORE the addition (+), which is the last thing that happens

l = [1, 2, 3]
print(iter_sum(l))
print(rec_sum(l))
Know that a *tail-recursive* function has the recursive call as *the very last thing that really happens* in the function. Note that this is **not** the case in `rec_sum`, where the last thing that really happens is the addition using `+`. A tail-recursive solution usually needs to provide an accumulator which is passed down into each recursive call:
def tail_sum(numbers, res=0):
    if not numbers:
        return res
    return tail_sum(numbers[1:], res + numbers[0])     # the recursive call is truely what happens last
print(tail_sum(l))
In both recursive implementations, there are three features common to most recursive code:
 1. one or more base cases
 2. one or more recursive calls
 3. somehow combining *this* data with *the recursive rest*

The most common ways you will encounter recursion is in recursive data structures ("files and folders").
## A few words on testing

It is very important that a test only tests **one specific thing**. For example, you were required to implement a test for the "Game Moves" task which ensures that a given implementation raises an exception if the game world dimensions are invalid. You might have come up with a test case like this:

```python
    def test_invalid_rowlength(self):
        state = (
            "#####   ",
            "### o  #",
            "#      #",
            "  "          # invalid row, not the same length as the others!
        )
        with self.assertRaises(Warning):
            move(state, "up")
```

But there's a problem with this test case. An implementation which **does not** check for invalid row dimensions, but **does** check for invalid moves will "correctly" raise a `Warning` here. In this test, the player is running `UP` into a wall, so a `Warning` will be raised anyway! So this test will **pass** even for a buggy implementation that does not check if each row has the same length! 

Here is a test case that does not suffer from this problem:

```python
    def test_invalid_rowlength(self):
        state = (
            "#####   ",
            "### o  #",
            "#      #",
            "  "          # invalid row, not the same length as the others!
        )
        with self.assertRaises(Warning):
            move(state, "down")
```

Now, the only thing wrong when calling `move` is that the world has rows of unequal length, everything else is valid. This way, the specific bug can actually be identified!
<p style="height:100px"></p>
<hr>
<p style="height:100px"></p>




## `map` and `filter`

In Python, if you want to *change* each value in a collection, or *filter* a collection, you would typically use a comprehension. For example, you might convert a list of strings to a list of integers like this:
l = ["1", "3", "5"]
[int(n) for n in l]
Or to get rid of all strings which are not numbers, you might do:
l = ["1", "a", "5", "11", "five"]
[n for n in l if n.isdigit()]
However, comprehensions are a fairly Python-specific idea. In most other programming languages, the functionality of comprehensions is covered by two functions called `map` and `filter`. Here is how we could implement these functions ourselves:

`my_map` takes a function and a collection of values. It calls the function for each value in the collection and returns a list with the resulting values. We say that `fun` is *applied* to each value in the collection.
def my_map(fun, collection):
    res = []
    for elem in collection:
        res.append(fun(elem))      # apply fun to elem -> transform
    return res                     # list of transformed values

l = ["1", "3", "5"]
my_map(int, l)                     # equivalent to [int(n) for n in l]
Likewise, `my_filter` takes a function and a collection of values. It calls the function for each value in the collection to determine whether to keep the element of to discard it and returns a list containing only those values from the original collection, where the function call evaluated as truthy.
def my_filter(fun, collection):
    res = []
    for elem in collection:
        if fun(elem):              # apply fun to elem -> filter
            res.append(elem)
    return res                     # list of values that passed the filter

l = ["1", "a", "5", "11", "five"]
my_filter(str.isdigit, l)          # equivalent to [n for n in l if n.isdigit()]
When comparing `my_filter(str.isdigit, l)` with `[n for n in l if n.isdigit()]`, remember that 
"5".isdigit()
is just syntactic sugar for:
str.isdigit("5")
So to illustrate that it's still `str.isdigit` which is applied to each value, you could rewrite the comprehension as
[n for n in l if str.isdigit(n)]
Python ships with these functions built-in. 
l = ["1", "3", "5"]
map(int, l)
l = ["1", "a", "5", "11", "five"]
filter(str.isdigit, l)
Notice that these are lazy-loading iterators, so to "see" their contents in Jupyter Notebook, we need to convert the result to a collection.
l = ["1", "3", "5"]
list(map(int, l))               # wrap in list(...) to see the result
l = ["1", "a", "5", "11", "five"]
list(filter(str.isdigit, l))    # wrap in list(...) to see the result
As you can see, `map` and `filter` are very simple functions that implement the modification and filtering capabilities provided by comprehensions in Python. The Python designers indeed recommend using comprehensions over the use of these functions. Most other languages, however, don't have comprehensions and simply provide `map` and `filter`. You should get comfortable with the idea.

The most important thing to understand is that the first parameter given to `map` and `filter` is always a function that takes one parameter.
 * In case of `map`, the return value (`5`) of the function call (`int("5")`) replaces the original element (`"5"`) in the resulting collection.
 * In case of `filter`, the return value (`True`) of the function call (`str.isdigit("5")`) determines whether the original item (`"5"`) should be kept in the resulting collection.

Let's see a few more examples:
# Get lengths of strings
words = ["apple", "banana", "cherry", "date"]
list(  map(len, words)         )          # [len(w) for w in words]
# Filter for strings containing only whitespace
l = ["  ", "hello", " ", "world", "\n", "\t"]
list(  filter(str.isspace, l)  )          # [s for s in l if s.isspace()]
# Round floating point numbers
decimals = [3.14159, 2.71828, 1.41421]
list(  map(round, decimals)    )          # [round(n) for n in decimals]
# Filter for truthy values
values = [0, None, False, "", 42, "hello", [], [1,2], {}]
list(  filter(bool, values)    )          # [v for v in values if v]
As you can see in each of those examples, the first parameter given to `map` or `filter` is a function that takes one parameter:

 * `map(len, words)`: `len` takes a collection and returns an integer
 * `filter(str.isspace, l)`: `str.isspace` takes a string and returns a boolean
 * `map(round, decimals)`: `round` takes a number and returns an integer
 * `filter(bool, values)`: `bool` takes anything and returns a boolean
However, what can we do if our transformation function for `map`, or our criteria for `filter` are more complicated than just a plain function? Let's say in the following example, that we want to remove all elements from a collection unless they are a list, tuple or dictionary. Instead of providing a ready-made function to `filter`, we could just implement a new function that we can pass as the first parameter to `filter`:
values = [0, None, False, "", 42, "hello", [], [1,2], {}]

def criteria(it):
    return isinstance(it, (list, tuple, dict))  # returns a boolean
    
print(list(  filter(criteria, values)   ))      # criteria is applied to each element
As you can see, we implemented a function `criteria` which takes one argument. This function is called for each element in the collection to determine whether to keep it or not. The `criteria` function returns True if `it` is one of the desired types.

Note that we cannot simply use `isinstance(it, (list, tuple, dict))` as the first parameter to `filter`, because that's not a function:

```python
# Here, the first parameter to filter is NOT a function
# This wouldn't work because what is *it*?
print(list(  filter(isinstance(it, (list, tuple, dict)), values)   ))
```

So that's why we had to create a function (`criteria`) first, and use it as a parameter to `filter`.
Here is a similar example for `map`. Say we want to add `1` to each number in a collection. Even for something so simple, we would still need to implement a separate function:
values = [1, 3, 5]
def adder(x):
    return x + 1
print(list(  map(adder, values)   ))
Again, we couldn't just use `x+1` as the first parameter:

```python
# Here, the first parameter to map is NOT a function
# This wouldn't work because what is *x*?
print(list(  map(x + 1, values)   ))
```
Having to define a new function and give it a name is a little bit cumbersome, especially if we're only going to use that function as part of a `map` or `filter` call but nowhere else. All we want to tell the `map` function is that "given a value, add one", or `x + 1`, without having to define the `adder` function.
## Lambdas / Anonymous functions

In a situation where we just need some functionality that we could put in a function (like `adder` above), we can make use of a language feature called *anonymous functions*. In Python and some other languages, this is referred to as a *lambda function*. We can turn our non-working example from above by simply adding `lambda x : ` in front of the `x + 1` which we want to pass into the `map` function:
values = [1, 3, 5]
print(list(  map(lambda x: x + 1, values)   ))    # the lambda acts the same as 'adder'
As you can see, it works exactly the same as if we were to pass in the `adder` function. However, instead of implementing `adder` as a separate, *named function*, we simply defined a lambda as the first parameter to `map`. The general syntax for lambdas in python is:

```python
lambda arguments: expression
```

`lambda` is really just another way to define functions. We could define a lambda function and then assign it to a variable. We would then have ended up with a regular function:
adder = lambda x: x + 1       # this is a bit silly
adder(3)
def adder(x):                 # identical
    return x + 1
adder(3)
However, if we do not assign the lambda to a variable, that means we cannot refer to it anywhere else (hence it is "anonymous"). Lambdas are a popular choice when defining ad-hoc functionality that is really only needed in place, such as
 * changing each value when calling `map`
 * filtering criteria when calling `filter`
 * sorting criteria  when calling `sorted` or `.sort()`

Let's look at some more examples.
# Filter list, tuple, dict from a collection 
values = [0, None, False, "", 42, "hello", [], [1,2], {}]
list(  filter(lambda x: isinstance(x, (list, tuple, dict)), values)   )  # instead of defining the `criteria` function
# Transform each string into a 2-tuple containing the length and upper-case version
words = ['hello', 'world', 'python']
list(  map(lambda x: (len(x), x.upper()), words)                      )
# Filter strings containing only whitespace
l = ["  ", "hello", " ", "world", "\n", "\t"]
list(  filter(str.isspace, l)                )    # no lambda needed
# Filter strings NOT containing only whitespace
l = ["  ", "hello", " ", "world", "\n", "\t"]
list(  filter(lambda x: not x.isspace(), l)  )    # lambda to invert the condition
Here's a function which simply compares if two functions produce the same result for a given argument:
def same_result(f, g, it):
    return f(it) == g(it)
print( same_result(len, sum, [1, 1]) )
print( same_result(str.title, str.upper, "world") )
print( same_result(bool, str.isdigit, "1") )
Now that you know about lambdas, you would also be able to use this function like so:
print( same_result(abs, lambda x: x if x > 0 else -x, -100) )
You do not necessarily need to use lambdas, but you must be able to recognize what they do and how they work.
## `sorted` and `.sort`

Another function which works rather similarily to `map` and `filter` is `sorted`. In the simplest case, it just takes a collection and returns it sorted according to the comparison operators (`__gt__` etc.) of the elments. Note that `sorted` does **not** modify the input collection. Here, it sorts a list of strings alphabetically (because that's how ordering of strings is implemented):
words = ["python", "c", "java", "javascript", "ada"]
sorted(words)
However, `sorted` can also take an optional keyword argument `key`:
words = ["python", "c", "java", "javascript", "ada"]
sorted(words, key=len)
As you can see, `key` is also expected to be a function (just like the first parameter to `map` or `filter`). In the example above, the function is `len`, which takes a collection as an argument and returns a number. `sorted` then uses that number to order the values in the collection. Thus, it sorts the strings by length, instead of alphabetically.
This is another case where `lambda` comes in handy. Say we want to sort students by their grade:
students = [('Alice', 5.75), ('Bob', 3.75), ('Charlie', 5.00)]
sorted(students, key=lambda x: x[1]) # does not modify students but returns a new collection
Some collections also provide a method `.sort`. It works the same, but actually modifies the collection in-place:
students = [('Alice', 5.75), ('Bob', 3.75), ('Charlie', 5.00)]
print(students)
students.sort(key=lambda x: x[1])   # sorts in-place, modifying students
print(students)
It's best to be familiar with `sorted` and `.sort` because it's such a common thing to do.
## `continue` and `break`

`for` loops usually are intended to run for each element in a collection, and `while` loops usually run until the condition becomes false:
# for loop typically iterates for each element
for i in ["Bob", "Anne", "Alice"]:
    print(i)

# while loop typically iterates until the condition is false
n = 3
while n > 0:
    print(n)
    n -= 1
When a using a `for` or `while` loop, you have some additional ways to control the flow of execution.

 * `continue` will end the current iteration of the loop and jump back to the beginning to execute the next loop (if there is any)
 * `break` will end the iteration entirely

In the following example, where a `for` loop iterates over each element in a list of strings, `continue` is used to jump to the next iteration if the string is essentially empty:
responses = [
    "Great service!",
    "",
    "   ",
    "Food was cold",
    "\n",
    "Will come back again"
]

for feedback in responses:
    if not feedback.strip():          # if, after stripping whitespace, there's nothing left, this is an invalid feedback
        continue                      # go to the next iteration
    print(feedback)
Similarily, the following example uses `break` to completely end the loop early under certain conditions:
responses = [
    "Good service",
    "Waiter was friendly",
    "Found hair in my food!",
    "Nice atmosphere",
    "Enjoyed the music"
]
for feedback in responses:    
    if "hair" in feedback.lower() or "bug" in feedback.lower():
        print(f"ALERT: Critical issue found: {feedback} -- act immediately!")
        break                        # end the for loop right here
    print(feedback)
Note that in many cases, your functionality will be contained in functions. If that's the case, then it's quite likely that you can simply use an early `return` instead of `break`, unless you want to continue with some more code after the `for` loop.
def analyze_feedback(responses):
    for feedback in responses:    
        if "hair" in feedback.lower() or "bug" in feedback.lower():
            print(f"ALERT: Critical issue found: {feedback} -- act immediately!")
            return                   # end the function right here
        print(feedback)
analyze_feedback(responses)
## Data classes

It happens with some frequency that a class you create mostly exists as a simply object to store some data. Here is an example:
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person("Bob", 33)
print(p1)
To make this class behave nicely, we would probably also want to implement `__str__`, `__repr__` and maybe some other methods. However, since this use case is very common, Python provides a helper called `dataclass` to create such classes more easily:
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int

p1 = Person("Bob", 33)
print(p1)
To create a data class, we simply annotate the class with `@dataclass`. Then, we list the desired attributes, in this case `name: str` and `age: int`. For data classes, type annotations are mandatory. As you can see, `@dataclass` automatically creates `__init__`, `__str__`, `__repr__`, `__eq__`, and some other functionality - very convenient!
p2 = Person("Bob", 33)
p3 = Person("Alice", 33)
print(p1)          # automatically implemented __str__
print(p2)
print(p3)
print(p1 == p2)    # automatically implemented __eq__
print(p1 == p3)
print([p1, p3])    # automatically implemented __repr__
It can even automatically implement other comparison operators, if you provide it with some additional arguments. Here, we say that instances of `Person` are "frozen" (i.e., immutable), and that we also want to automatically implement the comparison functions for ordering as well as `__hash__`:
@dataclass(order=True, frozen=True, unsafe_hash=True)
class Person:
    name: str
    age: int
    
p1 = Person("Bob", 33)
p3 = Person("Alice", 33)
print(hash(p1))
print(p1 > p3)

#p1.name = "Bobby"        # will generate an exception, because Persons are now immutable ("frozen")
You can also provide default values in the data class definition, and you can still implement additional methods as usual:
@dataclass
class Person:
    name: str
    age: int = 0

    def reach_birthday(self):
        self.age += 1
        
p1 = Person("Bob")
p3 = Person("Alice", 33)
print(p1)
p1.reach_birthday()
print(p1)
Just don't be confused by the syntax: `name` and `age` are NOT class attributes. You *could* add class attributes, but they must not have any type annotations:
@dataclass
class Person:
    name: str
    age: int = 0

    example_class_attribute = "Like a Toyota's serial_counter, this attribute only exists once."
        
p1 = Person("Bob")
p3 = Person("Alice", 33)
print(p1.name == p3.name)
print(p1.example_class_attribute == p3.example_class_attribute == Person.example_class_attribute)
You do not need to use data classes, but you should be able to recognize them and know how they work.
## Working with files

Python can read and write files on your machine. When working with files **be careful not to accidentally overwrite or delete your work**. You can destroy your operating system and trash all your files if you're not careful.

Let's say we have some data that we want to save to a file. In the following example, we open a file `cities.csv` in *write mode* (`'w'`). We can then write text to this file. Note that this will **overwrite** `cities.csv` as soon as something is written to it. We decide to store the data using simple CSV (comma-separated-values), where each value in the tuple will be separated by a comma `,` and each row by a newline `\n`.
cities = [
    (35.6839,  139.7744, "Tokyo"),
    (40.6943,  -73.9249, "New York"),
    (19.4333,  -99.1333, "Mexico City"),
    (18.9667,   72.8333, "Mumbai"),
    (-23.5504, -46.6339, "Sao Paulo"),
]

with open('cities.csv', 'w') as f:                          # open the file, referencing it as 'f'
    for line in cities:
        f.write(",".join([str(it) for it in line]) + '\n')  # write each row of our data
You can now open `cities.csv` in a text or spreadsheet editor to confirm that the file was indeed created. If you want to add data to a file, instead of overwriting it, you can specify *append mode* `('a')`:
with open('cities.csv', 'a') as f:                          # append mode 'a' instead of 'w'
    f.write("47.3764,8.5432,Zurich\n")
Reading a file works similarily. Let's read the file back into a data structure using *read mode* (`'r'`):
cities = []

with open('cities.csv', 'r') as f:                              # read mode 'r'
    content = f.read()                                          # read the entire file
    for line in content.splitlines():                           # split on newlines
        row = line.strip().split(',')                           # split on commas
        lat, lon, name = float(row[0]), float(row[1]), row[2]   # convert the numbers from strings where necessary
        cities.append((lat, lon, name))                         # add the resulting tuple to the cities list

print(cities)
A couple of things to note:

 * The `with ... as ...:` statement is called a *context manager*. It ensures that when the `with` block ends, the file is properly closed. There are other context managers in Python, but for now, you only need to know this one for reading and writing files.
 * When reading or writing binary data, you may need to use the `"wb"`, `"ab"` and `"rb"` modes. We did not really discuss binary data. Just be aware of this.
 * Above, we used `f.read()` to read the entire file content and then we split it. You could also use `f.readlines()` or `list(f)` to obtain the lines directly.
 * If you have a very large file, reading all of it at once may not be possible. You can use `f.readline()` to read just one line or `f.read(n)` to read `n` characters (or bytes when in binary mode). You can also move to a different position in the file using `f.seek(...)`.
 * Python ships with many libraries to work with specific file types, such as [CSV](https://docs.python.org/3/library/csv.html) [ZIP files](https://docs.python.org/3/library/zipfile.html) or other archives, [emails](https://docs.python.org/3/library/email.html), [JSON](https://docs.python.org/3/library/json.html), [HTML](https://docs.python.org/3/library/html.parser.html#module-html.parser), [XML](https://docs.python.org/3/library/xml.html), [SQLite databases](https://docs.python.org/3/library/sqlite3.html), and many more. In many of those cases, you can provide `f` directly to the library, and it will deal with actually reading and writing the files.

To learn all the more complex aspects of using files in Python, follow [the documentation](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files).
## Duck typing

You might have heard that Python uses "Duck Typing". The saying goes:

*"If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck."*

The idea here is important to understand: When writing programs in a *pythonic* fashion, type checks are not really really performed pre-emptively. Or in other words: **The *type* of an object is less important that its *behavior***.

In the following example, there is no explicit relationship between the three classes `Container`, `Bicycle` and `Goldbar`. The `Container` class simply assumes that all things it contains support the **same behavior**, namely that calling `.value()` on a stored thing will produce a number. A `Container` can store *anything* that exhibits this behavior:
class Container:
    def __init__(self):
        self.storage = []

    def store(self, thing):
        self.storage.append(thing)

    def total_value(self):
        return sum(thing.value() for thing in self.storage)    # Container assumes all things stored support the .value() behavior

class Bicycle:
    def __init__(self, make, model, price):
        self.make = make
        self.model = model
        self.price = price

    def value(self):
        return self.price

class Goldbar:
    def __init__(self, grams):
        self.grams = grams
        
    def value(self):
        from random import randrange
        return self.grams * randrange(50, 70)

container = Container()
bike = Bicycle("Trek", "Outrunner", 650)
bar = Goldbar(20)
container.store(bike)
container.store(bar)
print(container.total_value())
In other words:

*"If it has a `value()` method that produces a number, it must be something that can be stored"*

This allows for a lot of flexibility when implementing "open" programs. It stands in strong contrast to *strongly-typed* languages like Java or C++, where the two classes `Bicycle` and `Goldbar` would likely need to inherit from something like `Storable` and where `Container` would only accept to store objects that inherit from `Storable`.

Nonetheless, a Python programmer may decide to also implement a `Storable` class, just to make this relationship explicit. Naturally, this class may be *abstract* and specify that subclass must implement `value`:
class Container:
    def __init__(self):
        self.storage: list['Storable'] = []

    def store(self, thing: 'Storable'):
        self.storage.append(thing)

    def total_value(self):
        return sum(thing.value() for thing in self.storage)

from abc import ABC, abstractmethod
class Storable(ABC):
    @abstractmethod
    def value(self):
        pass

class Bicycle(Storable):
    def __init__(self, make, model, price):
        self.make = make
        self.model = model
        self.price = price

    def value(self):
        return self.price

class Goldbar(Storable):
    def __init__(self, grams):
        self.grams = grams
        
    def value(self):
        from random import randrange
        return self.grams * randrange(50, 70)

container = Container()
bike = Bicycle("Trek", "Outrunner", 650)
bar = Goldbar(20)
container.store(bike)
container.store(bar)
print(container.total_value())
## Multiple inheritance

You already know that if a class `Sub` inherits from a class `Super`, then `Sub` inherits ("copy-pastes") all functionality from `Super`. `Sub` can then override certain attributes, or may have to provide some explicitely (those inherited as `@abstractmethod`).

In the following example, `TextFile`, `ImageFile`, and `Folder` all inherit from `File`. They each inherit `__init__` but then override it with their own implementation, each of which calls `super().__init__`.
class File:
    def __init__(self, filename):
        self.filename = filename

class TextFile(File):
    def __init__(self, filename, text):
        super().__init__(filename)
        self.text = text

class ImageFile(File):
    def __init__(self, filename, pixels):
        super().__init__(filename)
        self.pixels = pixels
                         
class Folder(File):
    def __init__(self, filename):
        super().__init__(filename)
        self.content = []
Let's consider the following problem:

Email is a specified in [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322#section-2.1) as a text-only medium. Seriously! An email message may only contain US-ASCII (ANSI.X3-4.1986) characters. However...
  * your email client allows you to attach pictures or PDFs when sending a message
  * You can use Umlauts and other non-ASCII characters
  * when you receive a message, it might come as more than just plain text, like colors and styling

How is this possible? Here is what an email looks like when it contains an image attachment:

```
From: sender@example.com
To: recipient@example.com
Subject: =?UTF-8?Q?Gr=C3=BC=C3=9Fe_mit_Uml=C3=A4uten?=
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="boundary123"

--boundary123
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: quoted-printable
Gr=C3=BC=C3=9Fe aus M=C3=BCnchen! Hier ist ein sch=C3=B6nes Bild f=C3=BCr Sie=

--boundary123
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="g.gif"
R0lGODdhAwADAIABAAAAAP///ywAAAAAAwADAAACBAyCoFAAOw=

--boundary123--
```

As you can see, both the subject and message, as well as the image gets encoded as text somehow. The `Content-Transfer-Encoding` fields indicates that the text is encoded using a strategy called `quoted-printable` and the image is encoded as `base64`.

Taking some data and turning it into strings is a common idea called **serialization**. You *serialize* a value when turning into some kind of string, and you *deserialize* the string to end up with the original data. This is what your email client does when sending and receiving emails.

In our example, we may define a new interface for classes which support serialization. In Python, we'll do this by defining an abstract class `Serializable`. Here it is with a few type annotations.

Side note: to indicate that `deserialize` returns a `Serializable`, we want to add it as a type hint to the function, i.e. `-> Serializable`. But because this happens *inside* `Serializable`, it is not really defined yet. Because of this, Python (since version 3.7) supports using a string instead of a type, i.e. `-> 'Serializable'` which will be resolved once the class is fully defined.
from abc import ABC, abstractmethod

class Serializable(ABC):
    @abstractmethod
    def serialize(self) -> str:                     # serialize turns the object into a string representation
        pass

    @staticmethod                                   # static, because there is no object before deserialization
    @abstractmethod
    def deserialize(data: str) -> 'Serializable':   # deserialize turns a string into an object
        pass
In our example, we may not be able to support serialization for all file types. We can't assume that every `File` is serializable. Also, `Folder`s are probably more difficult to serialize. For now, we'll only support serialization for `TextFile` and `ImageFile`. To do this we:

 1. make them inherit from `Serializable`
 2. implement `serialize` and `deserialize`. We will choose an appropriate way to encode the text or image data as a string.
from abc import ABC, abstractmethod

class Serializable(ABC):
    @abstractmethod
    def serialize(self) -> str:                     # serialize turns the object into a string representation
        pass

    @staticmethod                                   # static, because there is no object before deserialization
    @abstractmethod
    def deserialize(data: str) -> 'Serializable':   # deserialize turns a string into an object
        pass

class File:
    def __init__(self, filename):
        self.filename = filename

class TextFile(File, Serializable):                 # TextFile now inherits from TWO classes, first File, then Serializable
    def __init__(self, filename, text):
        super().__init__(filename)
        self.text = text

    def __str__(self):
        return f"{self.filename}:\n{self.text}"

    def serialize(self):
        return f"{self.filename};{self.text}"       # serialization: it's easy: we just separate the file name and data by a semicolon

    @staticmethod
    def deserialize(data):
        name, text = data.split(';')                # deserialization: split the string on a semicolon to get the data back
        return TextFile(name, text)                 # construct the TextFile instance

class ImageFile(File, Serializable):                # ImageFile now inherits from TWO classes, first File, then Serializable
    def __init__(self, filename, pixels):
        super().__init__(filename)
        self.pixels = pixels

    def __str__(self):
        res = '\n'.join(["".join(["â–‘" if cell == 0 else "â–ˆ" for cell in row]) for row in self.pixels])
        return f"{self.filename}:\n{res}"

    def serialize(self):
        res = ""
        # separate file name by ; rows by , and pixels by .
        return f"{self.filename};" + ",".join(".".join(str(cell) for cell in row) for row in self.pixels)

    @staticmethod
    def deserialize(data):
        name, pixels = data.split(';')              # filename and data
        rows = pixels.split(',')                    # each row of pixels
        image = ([int(p) for p in row.split('.')] for row in rows)
        return ImageFile(name, image)               # construct the ImageFile instance
                         
class Folder(File):
    def __init__(self, filename):
        super().__init__(filename)
        self.content = []

t1 = TextFile("haiku.txt",
"""Indentation woes
Syntax errors multiply
Debug, try again""")

i1 = ImageFile("smile.img", (
    (0, 1, 0, 1, 0),
    (0, 0, 0, 0, 0),
    (1, 0, 0, 0, 1),
    (0, 1, 1, 1, 0),
))

t1_serialized = t1.serialize()                       # t1_serialized is now a string that contains all necessary data to restore t1
print(f"Serialized: {t1_serialized}")
t1_loaded = TextFile.deserialize(t1_serialized)      # we can greate an identical TextFile from the data
print(t1_loaded)

i1_serialized = i1.serialize()                       # i1_serialized is now a string that contains all necessary data to restore i1
with open("i1.txt", "w") as f:                       # we can store the serialized representation in a file
    f.write(i1_serialized)
with open("i1.txt", "r") as f:                       # we can load the serialized representation from a file
    i1_from_file = ImageFile.deserialize(f.read())
print(i1_from_file)
This is a practical example, where the additional super-class `Serializable` marks its descendants as supporting specific types of operations, i.e. being serialized into and reconstructed from a string. While many programming languages do not support multiple inheritance like Python, they usually support "implementing multiple interfaces" (`TextFile` could implement both the `File` and `Serializable` interfaces) or "including multiple mixins" (`TextFile` could inherit from `File` but include `Serializable` as a mixin).



`Serializable` itself only demands that two methods are implemented without providing any functionality on its own. But additional superclasses don't have to be abstract and could also just provide ready-made implementations. In the most trivial case, it could be entirely unrelated functionality:
class DiscoMode:
    def party(self):
        print("ðŸŽˆðŸŽ‰ ðŸ’ƒ âœ¨ ðŸ•º ðŸŽˆ ðŸ’ƒ âœ¨ ðŸ•º ðŸŽ‰ðŸŽˆ")
        
class File:
    def __init__(self, filename):
        self.filename = filename
        
class TextFile(File, DiscoMode):
    def __init__(self, filename, text):
        super().__init__(filename)
        self.text = text

    def __str__(self):
        return f"{self.filename}:\n{self.text}"

t1 = TextFile("password.txt", "hunter2")
t1.party()
But it could also make some assumptions about the kinds of classes which will inherit from it to provide ready-made functionality. In the following example, `Rot13` provides a method `encode`, which will return the `self.text` property encoded using rot13. It does not by itself set this! `Rot13` does not provide a constructor at all, just the `encode` method. Any class that has a `self.text` string attribute could inherit from `Rot13` to get this functionality *"mixed in"*. In many languages, this is called a "mixin". Strictly speaking, mixins are a language feature where functionality is added *without inhertance*, so in Python, this is not strictly speaking a mixin, but it illustrates how a mixin could be used in other languages:
class Rot13:
    def encode(self):
        import codecs
        return codecs.encode(self.text, "rot13")   # Rot13 could be mixed in with any class that has a self.text string attribute!

class File:
    def __init__(self, filename):
        self.filename = filename
        
class TextFile(File, Rot13):                       # Rot13 is technically a superclass, but semantically a mixin
    def __init__(self, filename, text):
        super().__init__(filename)
        self.text = text

    def __str__(self):
        return f"{self.filename}:\n{self.text}"

from dataclasses import dataclass
@dataclass
class Book(Rot13):                                 # The Book class has nothing to do with files, but the Rot13 mixin is compatible!
    author: str
    title: str
    text: str
    
t1 = TextFile("password.txt", "hunter2")
print(t1.encode())
b1 = Book("George Orwell", "Animal Farm", "Mr. Jones, of the Manor Farm, had locked the hen-houses...")
print(b1.encode())
To summarize, so far we've seen the following examples for how multiple inheritance might be used:

 * Marking classes as supporting a certain interface (like `Serializable`), where the inheriting classes must provide implementations.
 * Adding unrelated functionality (`DiscoMode`) to a class.
 * Adding functionality to certain compatible classses (`Rot13` is compatible with `TextFile` and `Book`, even though there is no semantic "family relationship" between `TextFile` and `Book`).
In the use cases above, there is little risk of problems when inheriting from mutliple super-classes (or in other languages: implementing multiple interfaces or including multiple mixins).

But what happens if there is an overlap between attribute names in different super classes? In the following example, `Book` inherits from both `Rot13` and `Screamer`, both of which provide a method called `encode`. When this happens, and we call `encode` on a `Book` instance, the *Method Resolution Order (MRO)* in Python is to use whichever method was imported *first*:
class Rot13:
    def encode(self):
        import codecs
        return codecs.encode(self.text, "rot13")

class Screamer:
    def encode(self):
        return self.text.upper()
        
from dataclasses import dataclass
@dataclass
class Book(Rot13, Screamer):
    author: str
    title: str
    text: str

b1 = Book("George Orwell", "Animal Farm", "Mr. Jones, of the Manor Farm, had locked the hen-houses...")
print(b1.encode())  # calls Rot13.encode, because that was inherited from FIRST!
If we wanted to use `Screamer`'s method, we would have to call the method by naming the class explicitely:
print(Screamer.encode(b1))
The same is true when calling `super()` methods. Below is an example where `House` inherits both `Taxable` and `Insurable`. There are two problems with this:
 1. both superclasses provide a method called `calculate`, so which one to use when calling `house.calculate()`?
 2. when creating a `House`, we need to call **both** super constructors, but `super().__init__` can only be one of them. Which one?

Here, Python will pick the `Taxable` implementations of `calculate` and `__init__` because `House` inherits from `Taxable` before `Insurable`. We solve the two problems as follows:
 1. If we want the `Insurable` implementation, we must call `Insurable.calculate(house)`
 2. Instead of `super().__init__` we refer to `Taxable.__init__` and `Insurable.__init__` directly. Note that now we have to also provide `self` as an argument!
class Taxable:
    def __init__(self, value, tax_rate):
        self.value = value
        self.tax_rate = tax_rate

    def calculate(self):
        return self.value * self.tax_rate

class Insurable:
    def __init__(self, value, copay):
        self.value = value
        self.copay = copay

    def calculate(self):
        return self.value - self.copay
        
class House(Taxable, Insurable):
    def __init__(self, address, value, tax_rate, copay):
        Taxable.__init__(self, value, tax_rate)               # instead of using super().__init__
        Insurable.__init__(self, value, copay)
        self.address = address

house = House(
    "112 Mercer Street, Princeton, New Jersey 08540",
    1650000,
    0.0214,
    8200
)

print(house.calculate())                                      # same as Taxable.calculate(house)
print(Taxable.calculate(house))
print(Insurable.calculate(house))
As a general piece of advice, while inheritance can be a fun way to come up with seemingly elegant abstractions, consesus in the developer community is shifting to a preference for flat and simple inheritance structures.

Otherwise, you might end up with something like the Scala collections types (pre Scala 2.13):

<div>
<img src="scala.svg" alt="Scala types" width=800 />
</div>

The Scala developers have since simplified the types a bit:

<div>
<img src="scala2-13.svg" alt="Scala types" width=600/>
</div>
# Summary

#### `map`, `filter`, `sorted`, `.sort`
* `map` takes a function and applies it to each element in a collection. It returns a new collection of transformed values.
* `filter` takes a function and determines it to each element in a collection to determine whether to keep or discard it. It returns a new collection of filtered values.
* `sorted` returns an ordered collection. A function can be optionally be provided as a `key=` argument. The function will be called for each element in the collection. The resulting values will be used to sort the collection.
* `.sort` sorts in-place.

#### `lambda`
* Anonymous functions can be provided ad-hoc without creating a named function. This is often done when a function argument must be a function, but it is only used once. The syntax is `lambda arguments: expression`.

#### `continue`, `break`,
* `continue` ends the current iteration of a `for` or `while` loop and goes to the beginning of the next (if any) iteration.
* `break` ends the execution of a `for` or `while` loop entirely.
  
#### `@dataclass`,
* `@dataclass` as imported by `from dataclasses import dataclass` can be used to automatically generate constructors, str/repr and many other functions by annotating a class. The attributes of each instant are defined as type-annotated attributes. These are not to be confused with class attributes in normal classes.

#### Duck typing
* Duck typing refers to the idea that the type of an object is less important than its implemented behavior. As long as an object can provide the expected methods and/or attributes, it could be considered a "compatible type" without using any typing.

#### Multiple inheritance
* If a class inherits from multiple classes which provide attribute with the same name, the first-imported one will be used
* To access other super-implementations with the same name, explicitely naming the superclass is necessary
* When having to call super-methods from multiple parents, `super()` will only ever provide the first-imported implementation.# Version Control and Git Notebook

This notebook is designed to be a complementary resource for the **Version Control and Git** chapter of the **Informatics I** lecture at the **University of Zurich**, authored by Melih Catal (catal@ifi.uzh.ch).  
It demonstrates how to use Git and GitHub for version control and collaboration. The outline of the notebook is as follows:

- [1. Getting Started with Git](#1.-Getting-Started-with-Git)  
- [2. Creating a Repository](#2.-Creating-a-Repository)  
- [3. Git Workflow](#3.-Git-Workflow)  
    - [3.1. Updating the Working Directory](##3.1.-Updating-the-Working-Directory)
    - [3.2 Adding Changes to the Staging Area](##3.2.-Adding-Changes-to-the-Staging-Area)
    - [3.3. Committing Changes to the Repository](##3.3.-Committing-Changes-to-the-Repository)
    - [3.4. Viewing the Commit History](##3.4.-Viewing-the-Commit-History)
    - [3.5 Checking the Differences](##3.5.-Checking-the-Differences)
        - [3.5.1 Comparing the Working Directory with the Staging Area](###3.5.1-Comparing-the-Working-Directory-with-the-Staging-Area)
        - [3.5.2 Comparing the Staging Area with the Repository](###3.5.2-Comparing-the-Staging-Area-with-the-Repository)
        - [3.5.3 Comparing the Working Directory with the Repository](###3.5.3-Comparing-the-Working-Directory-with-the-Repository)
- [4. Collaborating with Git](#4.-Collaborating-with-Git)  
    - [4.1 Cloning a Remote Repository](##4.1.-Cloning-a-Remote-Repository)
    - [4.2 Working with Branches](##4.2.-Working-with-Branches)
      - [4.2.1 Creating a New Branch](###4.2.1-Creating-a-New-Branch)
    - [4.3. Pushing Changes to the Remote Repository](##4.3.-Pushing-Changes-to-the-Remote-Repository)
    - [4.4. Merging Branches](##4.4.-Merging-Branches)
        - [4.4.1 Merge Conflicts](###4.4.1.-Merge-Conflicts)
    - [4.5. Pull Requests](##4.5.-Pull-Requests)
- [5. Exclude Files from Git](#5.-Exclude-Files-from-Git)  
- [6. Conclusion](#6.-Conclusion) 
- [7. Further Reading](#7.-Further-Reading)
    - [7.1. Fetch vs. Pull](##7.1.-Fetch-vs.-Pull)
    - [7.2. Rebasing vs. Merging](##7.2.-Rebasing-vs.-Merging)
---
# 0. Before You Start

Code cells contain commands for working with Git. Most commands begin with an exclamation mark (`!`) to indicate they are shell commands, which is necessary when running them in a Jupyter notebook. If you wish to execute these commands in your terminal, you can remove the exclamation mark.  

Some commands begin with a percent sign (`%`), denoting Jupyter magic commands. These commands are specific to Jupyter notebooks and are not applicable in the terminal. They are used to modify the notebook's behavior or environment.  

Please run the following examples to better understand how shell commands work in Jupyter notebooks.
# echo command is used to print the message on the screen. In the terminal, we would use as echo "Hello World". But in the notebook, we need to add ! before the command to execute it. 
# The command is the same but with ! in front of it. This prefix applies to all the commands in the notebook.

!echo "Hello World"

# Now please copy the above command and remove the ! from it and run it in the terminal. You will see the same output as in the notebook.
# 1. Getting Started with Git
### Git Configuration

Before starting, we need to ensure Git is installed on our local machine. You can find installation instructions [here](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git).

To verify if Git is installed, run the following command in your terminal:
# Lets check if the git is installed
!git --version
If this is your first time using Git, you need to configure your username and email address. This information is used to identify you as the author of the changes you make. Git configurations can be set at the **global** level (affecting all repositories) or the **local** level (specific to one repository).

To check your current Git configurations, use the following commands:

```bash
git config --local --list
git config --global --list
or
git config --list
or
git config --get <key> i.e. git config --get user.name
```

To set your username and email globally (applies to all repositories):

```bash
git config --global user.name "Your Name"
git config --global user.email "Your Email"
```

To set your username and email for a specific repository only:

```bash
git config user.name "Your Name"
git config user.email "Your Email"
```

You can learn more about username and email configuration [here](https://docs.github.com/en/get-started/getting-started-with-git/setting-your-username-in-git) and [here](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-email-preferences/setting-your-commit-email-address).

!git config --global --list
!git config --global --get user.name
!git config --global user.name "Your Name"
!git config --global user.email "your_email@example.com"
# 2. Creating a Repository

Repositories serve as containers for organizing your project files and tracking changes to them over time. They store the complete history of modifications, making it easy to manage and review your projectâ€™s development process.

You can create a new repository on your local machine to start tracking a project. A repository initializes a Git directory within your project folder, enabling version control. Once initialized, you can add files, commit changes, and collaborate with others by linking to a remote repository. We are going to create a new repository named `info1_local`.
First, create a new directory named info1_local in the current working directory and navigate into it. This will serve as the location for your new project:
# `%` is used to run magic commands in Jupyter Notebook. These commands will allow us to work within the `info1_local` directory for the rest of the notebook.
# Creating a new directory named `info1_local` in the current working directory.
!mkdir info1_local 
%cd info1_local 
We can now initialize a new Git repository in this directory. This action will create a hidden directory, `.git`, which contains all the necessary files for version control.

A repository serves as a virtual storage for your project. It tracks changes to your files, allows you to revert to previous versions, and facilitates collaboration with others.

The command `git init` initializes a new repository in the current directory. If everything is set up correctly, you should see a message like:  
`Initialized empty Git repository in .../info1_local/.git/`>
!git init
Software development is a collaborative process, and Git enables multiple developers to work on the same project simultaneously. To distinguish between contributors, Git requires a username and email address, which are used to identify the author of changes.

You can configure this information at three levels: **local**, **global**, and **system**. Previously, we set the global configuration, which applies to all repositories on your machine. For this project, however, letâ€™s assume you want to use a different email address. Git allows you to set a **local configuration**, which is specific to the current repository (in this case, `info1_local`).

By using local configuration, you can customize your username or email address for individual repositories, while global configuration serves as a default. System configuration, on the other hand, is applied universally to all users on the machine.

Below, weâ€™ll set the local configuration for the `info1_local` repository.
!git config --local user.name "Your Name" # Add your name
!git config --local user.email "your_email@example.com" # Add your email

We can easily check the configuration settings using the `git config --list` command. This command displays all the configuration settings for the current repository. In the output, you should see the username and email address specific to the local configuration, which may differ from the global configurations.
!git config --local --list
!git config --global --list
# 3. Git Workflow
<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/dMsl3zygSYZSdMX/download" alt="merge" width="800"/>
</div>

The typical Git workflow consists of three main stages: **working directory**, **staging area**, and **repository**. 

- The **working directory** is where you make changes to your files.  
- The **staging area** is where you prepare changes to be committed.  
- The **repository** is where the committed changes are stored.  

The `git add` command moves changes from the working directory to the staging area, and the `git commit` command moves changes from the staging area to the repository. 

This workflow applies only to the local repository. To synchronize your local repository with a remote repository (e.g., GitHub), you need to use the commands `git pull` and `git push`. We will cover these commands in detail later in the notebook. Specifically, `git pull` retrieves changes from the remote repository and integrates them into your local repository, while `git push` uploads your local commits to the remote repository.

In this section, we will focus on the local workflow: specifically, creating a new file, adding it to the staging area, and committing it to the repository.




## 3.1 Updating the Working Directory

In this step, we will create a new file named `hello.txt` in the `info1_local` directory. To do this, we can use the `echo` command, which writes text to the standard output. By redirecting the output with the `>` operator, we can create a new file or overwrite an existing file. If you want to append text to an existing file instead, you can use the `>>` operator, which adds text to the end of the file.

Initially, our working directory was empty, as can be seen in the `git status` output. After creating the `hello.txt` file, the working directory will no longer be empty. We can confirm this by running the `git status` command again. The output will indicate that there is an **untracked file**, `hello.txt`, in the working directory.

An untracked file is a file that Git is not currently tracking. To start tracking the file, we need to add it to the **staging area** using the `git add` command.

We can check the status of the repository using the `git status` command. This command displays the state of the **working directory** and the **staging area**. If there are any changes, they will be listed as **untracked**, **modified**, or **deleted**. If there are no changes, the output will display:
`nothing to commit, working tree clean`.

<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/aJtFRRzK6veHpnD/download" alt="merge" width="800"/>
</div>
!git status
!echo "Hello World from info1 lecture!" > hello.txt
We can verify if the file was created successfully by using the `ls` command. This command lists all files and directories in the current directory. The output should include the `hello.txt` file, confirming its creation.

We can also verify the contents of the `hello.txt` file using the `cat` command. This command reads the file and displays its contents. The output should show the text:  
`Hello World from info1 lecture!`
!ls 
!cat hello.txt

<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/08XxU2Cs2w3atME/download" alt="merge" width="800"/>
</div>

Finally, let's check the status of the repository again using the `git status` command. The output should indicate that there is an **untracked file**, `hello.txt`, in the working directory. 

An untracked file is one that Git is not currently monitoring. To begin tracking this file, we need to add it to the **staging area**, which we will do in the next section.
!git status
## 3.2 Adding Changes to the Staging Area


<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/GKo4oYWeOYFM4ZI/download" alt="merge" width="800"/>
</div>


Staging is the process of preparing changes to be committed to the repository. The **staging area** allows you to group related changes together before committing them. 

You can add changes to the staging area using the `git add` command, which moves changes from the **working directory** to the **staging area**. Changes can be added individually, by directory, or all at once. In this case, we will add the `hello.txt` file to the staging area.

```bash
git add hello.txt
```

If you want to add all changes in the working directory to the staging area, you can use the following command:

```bash
git add .
```

Here, the . represents the current directory and includes all changes within it.

After adding the changes, we can verify the status of the repository using the git status command. The output should indicate that the hello.txt file has been added to the staging area, making it ready to be committed to the repository.
!git add hello.txt
!git status
## 3.3 Committing Changes to the Repository

<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/0JZQtqNmF28Mkio/download" alt="merge" width="800"/>
</div>



After adding changes to the staging area, we can commit them to the repository using the `git commit` command. A **commit** represents a snapshot of the changes made to your files, effectively saving a checkpoint in your project's history.

To ensure the integrity of the snapshot, Git hashes the contents of the commit along with its metadata (e.g., author, date, commit message), generating a unique commit hash. This hash uniquely identifies the commit, prevents data corruption, ensures the integrity of the commit history, and optimizes memory usage, making it faster to access previous commits.

The `git commit` command moves changes from the **staging area** to the **repository**. When committing changes, you need to provide a concise and descriptive commit message. This can be done inline using the `-m` flag, followed by the message in quotes. For example:

```bash
git commit -m "Create hello.txt file"
```

After committing the changes, you can verify the repositoryâ€™s status using the git status command. The output should display:

`nothing to commit, working tree clean`

This indicates that all changes have been committed to the repository, and the working directory is clean.



!git commit -m "Create hello.txt file"
!git status
So, we have successfully walked through the Git workflow, from updating the working directory to committing changes to the repository. This process allows you to track changes to your files, create snapshots of your project at different stages, and collaborate with others by sharing your repository. After the commit, the working directory and staging area are empty, and the repository contains the committed changes.

<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/3kxTxwFwowyuBHK/download" alt="merge" width="800"/>
</div>



It is also possible to combine the `git add` and `git commit` commands into a single step using the `-a` flag with the `git commit` command. The `-a` flag automatically stages **all modified** files before committing them. For example:

```bash
git commit -a -m "Add another line to hello.txt"
```

This command stages all modified files and commits them with the specified message, providing a convenient way to commit changes without explicitly adding them to the staging area.

However, the -a flag does not work for new files that have not been previously tracked by Git. For untracked files, you still need to use git add before committing.

To demonstrate the use of the -a -m flag, we will update the contents of the hello.txt file and commit the changes in one step.
!echo "Another line" >> hello.txt
!git status
!git commit -a -m "Add another line to hello.txt"
!git status
## 3.4 Viewing the Commit History

Tracking the changes you make to your files is crucial for understanding your project's development. The **commit history** provides detailed information about the changes, including who made them, when they were made, and the commit messages describing them.

You can view the commit history using the `git log` command. This command displays the commits in reverse chronological order, showing details such as:

- The commit hash
- The author
- The date
- The commit message

To make the log easier to read, you can also visualize it using additional options or tools. For example:

- `git log --oneline`: Displays a compact view with one commit per line.
- `git log --graph`: Adds a visual representation of the branch structure.
- `git log --graph --oneline`: Combines both for a clean and visual summary.

These options allow you to explore the commit history more effectively.
!git log
!git log --oneline
!git log --graph
!git log --graph --oneline
## 3.5 Checking the Differences

<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/e2MwHlPUtRh2ZjD/download" alt="merge" width="800"/>
</div>

When working on a project, it is essential to understand the changes you have made to your files. Git provides a way to compare the current state of your files with previous versions, allowing you to see what has been added, modified, or deleted. This comparison is known as a **diff**. We will demonstrate how to view the differences between the working directory, the staging area, and the repository.

To view the differences between the working directory and the staging area, you can use the `git diff` command. This command compares the files in the working directory with the staging area, showing the changes that have not been staged yet.

To view the differences between the staging area and the repository, you can use the `git diff --staged` command. This command compares the files in the staging area with the repository, showing the changes that have been staged but not committed yet.

It is also possible to compare the working directory with the repository directly using the `git diff HEAD` command. This command compares the files in the working directory with the repository, showing all changes made since the last commit.

### 3.5.1 Comparing the Working Directory with the Staging Area

Comparing the working directory with the staging area allows you to identify which changes are staged for commit and which are still unstaged. This comparison is essential for reviewing your modifications, ensuring that only the desired changes are committed, and maintaining a clear and organized project history.
!echo "Adding a new line" >> hello.txt
!git diff
### 3.5.2 Comparing the Staging Area with the Repository
Let's add the changes to the staging area. We can then compare the staging area with the repository using the `git diff --staged` command. This command displays the differences between the files in the staging area and the repository, highlighting the changes that have been staged but not committed yet.
!git add hello.txt
!git diff --staged
### 3.5.3 Comparing the Working Directory with the Repository

Finally, we can compare the working directory with the repository using the `git diff HEAD` command. This command shows the differences between the files in the working directory and the repository, providing a comprehensive overview of all changes made since the last commit. `HEAD` refers to the most recent commit in the repository, allowing you to compare the current state of your files with the latest snapshot.
!echo "Adding one more line" >> hello.txt
!git diff HEAD
# 4. Collaborating with Git

Collaboration is a fundamental aspect of software development, and Git facilitates seamless teamwork by allowing multiple developers to work on the same project simultaneously. Effective collaboration requires synchronizing changes, managing branches, and resolving conflicts.

In this section, we will cover the basic commands and workflows for collaborating with Git, including:

- Cloning a remote repository
- Creating and working with branches
- Making changes and committing them
- Resolving merge conflicts
- Pushing changes to the remote repository

These concepts and commands form the foundation of collaborative development with Git.
## 4.1 Cloning a Remote Repository

So far, you have worked on your local repository. Now, to collaborate with others, you need a **central repository** where you can share your code and synchronize changes with other developers. Such a central repository is called a **remote repository**. Popular Git hosting services like GitHub, GitLab, and Bitbucket provide remote repositories for collaboration.

Suppose you found a repository on GitHub that you want to work on. You can create a local copy of the remote repository by **cloning** it. Cloning copies all the files, directories, and history from the remote repository to your machine. This is done using the `git clone` command followed by the URL of the remote repository.

In this example, we will clone the repository '[melihcatal/info1_remote](https://github.com/melihcatal/info1_remote.git)' from GitHub. Once the cloning process is complete, you can navigate into the cloned repository's directory using the `cd` command. The cloned directory will contain all the files and folders from the remote repository.

Before cloning, ensure that you are in the directory where you want to create the local copy of the remote repository. Since we created the `info1_local` directory earlier and are currently in it, we first need to navigate back to the parent directory. After that, we can clone the remote repository there.
# Note the magic command % again.
%cd ..
!git clone https://github.com/melihcatal/info1_remote.git
Now, you should see the `info1_remote` directory in the current directory. You can navigate into the `info1_remote` directory using the `cd` command.
# We are again using the magic command `%` to change the directory. This ensures that the notebook is set to use the `info1_remote` directory for the rest of the operations.
%cd info1_remote
Let's check the contents of the `info1_remote` directory using the `ls` command. The output should show a file named `greetings.txt`. This file contains a greeting message from the remote repository.
!ls
!cat greetings.txt

What about the commit history of this repository? We can view it using the `git log` command. The output will display the commit history of the remote repository, including details like commit hashes, authors, dates, and messages.
!git log
## 4.2 Working with Branches

<div style="text-align: center;">
  <img src="https://miro.medium.com/v2/resize:fit:1400/0*jTl3JhJiDoI3ncml" alt="merge" width="800"/>
</div>

Branches are independent lines of development in Git, enabling you to work on different features or fixes simultaneously without impacting the main codebase. Each branch is a unique copy of the codebase along with its history. Branches facilitate parallel workflows, support collaborative development, and protect the main codebase from experimental changes.


### 4.2.1 Creating a New Branch

So far, we have been working on a single branch, the **main branch**. A branch is a parallel version of the codebase that allows you to work on new features, bug fixes, or experiments without impacting the main codebase. 

Branches are lightweight and easy to create. You can create a new branch using the `git branch` command followed by the branch name. To start working on the new branch, you must switch to it using the `git checkout` command followed by the branch name.

In this example, we will:
1. Create a new branch named `greetings_YOURNAME`.
2. Switch to the new branch.

Once you are on the new branch, any changes you make will be isolated from the main branch. These changes will not affect the main branch until you explicitly merge them back.
We can check the current branch using the `git branch` command. The output will list all the branches in the repository, with an asterisk (*) indicating the current branch. Initially, we should see the `main` branch with an asterisk next to it.
!git branch
Let's create our own `greetings` branch and edit the `greetings.txt` file to add our own greeting message.

<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/MLNQmiNRvvKQBIV/download" alt="merge" width="800"/>
</div>
!git branch greetings_YOURNAME # i.e. greeetings_melih
Let's check the branch list again using the `git branch` command. This time, we should see both the `main` and `greetings_YOURNAME` branches. However, the asterisk (*) will still be next to the `main` branch, indicating that we are currently on the `main` branch. To make changes to the file without affecting the `main` branch, we need to switch to the `greetings_YOURNAME` branch.
!git branch
<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/7avEmuMi02MA5tn/download" alt="merge" width="800"/>
</div>

How do we switch to the new branch, `greetings_YOURNAME` branch? We can use the `git checkout` command followed by the name of the branch we want to switch to. In this case, we will run the following command to switch to the `greetings_YOURNAME` branch:
!git checkout greetings_YOURNAME
!git branch
Now we can work on the file with peace of mind, knowing that our changes will not affect the `main` branch. Let's edit the `greetings.txt` file to add our own greeting message.

We can use the `echo` command to append text to the file. In this example, we will add the text `Hello from Melih` to the file. Feel free to replace "Melih" with your own name! ðŸ˜„

To append text to the end of the file, we will use the `>>` operator:

```bash
echo "Hello from Melih" >> greetings.txt
```

If we had used the > operator instead, it would have overwritten the file instead of appending to it.

!echo "Greetings from Melih!" >> greetings.txt
!cat greetings.txt
Now, this change simulates the type of modifications you would make to a code file. After making the changes, we can check the status of the repository using the `git status` command. 

The output should indicate that the `greetings.txt` file has been modified. At this stage, the modified file is still in the **working directory**. To commit these changes to the repository, we first need to add them to the **staging area** using the `git add` command.
!git status
We can also view the changes we made to the file using the `git diff` command. This command displays the differences between the **working directory** and the **staging area**.

The output will show the specific changes made to the file. In this case, it will highlight the addition of the text:  
`Hello from Melih`  
to the `greetings.txt` file.
!git diff
!git add .
What is the current status of the repository?
!git status
<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/I9jqv7CTTsi9Pmg/download" alt="merge" width="800"/>
</div>

Alright, the output is self-explanatory. It indicates that the `greetings.txt` file has been modified and is ready to be committed. 

Letâ€™s go ahead and commit the changes to the repository. Even though we initially cloned this repository from a remote repository, we are currently working on our **local repository**. All these changes are local, and Gitâ€™s three stagesâ€”**working directory**, **staging area**, and **repository**â€”operate within the local environment.

You donâ€™t interact with the remote repository until you explicitly **push** changes to it or **pull** changes from it.
!git commit -m "Edit greetings.txt file with greetings from Melih"
!git status
We have successfully committed the changes to the repository. Make sure to always provide a **descriptive commit message** that clearly explains the changes you made. 

Good commit messages are crucial for helping your future self or your team members understand the purpose of a commit. They make it easier to track changes, debug issues, and find specific modifications when needed. Trust me, it will save you from a lot of headaches down the roadâ€”weâ€™ve all been there! ðŸ˜„
## 4.3 Pushing Changes to the Remote Repository

Awesome! Now we are ready to push our changes to the remote repository so that others can see them and collaborate with us. To push changes to the remote repository, use the `git push` command followed by the **remote name** and **branch name**.

- The remote name is typically `origin`, which is the default name for the remote repository when cloned.
- The branch name is the name of the branch you want to push. 

In this case, we will push the changes to the `greetings_YOURNAME` branch. Since the remote repository currently does not have a `greetings_YOURNAME` branch, Git will create it when we push the changes. Feel free to replace `greetings_YOURNAME` with your own branch name.

The basic template for the `git push` command is:

```bash
git push <remote_name> <branch_name>
```

For example, to push the changes to the `greetings_YOURNAME` branch, we will use:

```bash
git push origin greetings_YOURNAME
```

If you want to push changes from your local branch to a differently named branch in the remote repository, you can use the following syntax:

```bash
git push <remote_name> <local_branch_name>:<remote_branch_name>
```

For example, to push changes from the `greetings_YOURNAME` branch to a differently named branch `greetings_YOURNAME_remote` in the remote repository, you can use:

```bash
git push origin greetings_YOURNAME:greetings_YOURNAMEremote
```

You can list all remote repositories associated with your local repository using the git remote command. This will display the remote repository names, such as origin. To view all branches in the remote repository, use the `git branch -r` command. The `-r` flag stands for "remote2. In this case, the output should show the main branch as it exists in the remote repository.

!git remote
!git remote -v
!git branch -r
!git push origin greetings_YOURNAME
Again, the output tells us a lot. It confirms that a new branch, `greetings_YOURNAME`, has been created in the remote repository. This branch is now available for others to view and collaborate on.

The output also displays the URL of the remote repository. This URL is used to push changes to the remote repository and serves as the link for synchronization between the local and remote repositories.
## 4.4 Merging Branches

<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/bIEQL7CIR7S6ZOS/download" alt="merge" width="800"/>
</div>

Now that we have successfully edited a file on a separate branch and pushed the changes to the remote repository, we are confident that our changes are correct and production-ready. Itâ€™s time to merge these changes into the `main` branch.

**Merging** is the process of combining changes from one branch into another. You can use the `git merge` command followed by the branch name to perform the merge. In this case, we will merge the `greetings_YOURNAME` branch into the `main` branch.

The `git merge` command combines the changes from the specified branch into the current branch. To incorporate the changes from the `greetings_YOURNAME` branch into the `main` branch, follow these steps:

1. **Switch to the `main` branch**:
   Use the `git checkout` command to switch to the `main` branch:
   ```bash
   git checkout main
    ```
2. **Merge the `greetings_YOURNAME` branch**:
Use the git merge command to merge the changes from the greetings_YOURNAME branch:
```bash
git merge greetings_YOURNAME
```

The template for the git merge command is:
```bash
git merge <branch_name>
```

This merges the specified branch into the current branch.


!git checkout main
!git branch
!git merge greetings_YOURNAME
!cat greetings.txt
### 4.4.1 Merge Conflicts

**Merge conflicts** occur when two branches have made changes to the same line in a file, and Git cannot automatically determine which change to keep. In such cases, you must manually resolve the conflict.

In this section, we will simulate a merge conflict by making changes to the same line in the `greetings.txt` file on both the `main` branch and the `greetings_YOURNAME` branch. We will then attempt to merge the branches to observe how Git identifies and handles the conflict.

This process will demonstrate how to resolve conflicts and proceed with the merge.
First, let's ensure that we are on the `main` branch. We can use the `git branch` command to check the current branch. The output will list all branches, with an asterisk (*) indicating the current branch.

If you are not on the `main` branch, switch to it using the `git checkout` command:

```bash
git checkout main
```
!git branch
# !git checkout main
# !git branch

Now that we are on the `main` branch, let's edit the `greetings.txt` file to add a new greeting message. 

We will use the `echo` command to append text to the file. This time, we will add the text `Hello from the main branch` to the file. To append the text without overwriting the existing content, we will use the `>>` operator:
!echo "Hello from the main branch. Waiting for the merge conflict :P" >> greetings.txt

Let's ensure the file has been edited successfully. Use the `cat` command to display the contents of the file.
!cat greetings.txt
Great! The file has been edited successfully. Now, let's add the changes to the **staging area** and commit them to the **repository**:

1. Add the changes to the staging area:
   ```bash
   git add .
    ```

2. Commit the changes with a descriptive message:
    ```bash
    git commit -m "Edit greetings.txt file with greetings from main branch"
     ```
!git add .
!git commit -m "Edit greetings.txt file with greetings from main branch"
!git log
For our simulation, we will switch back to the `greetings_YOURNAME` branch and edit the same file, `greetings.txt`. This time, we will add the text `Greetings from Melih! I am waiting for the merge conflict as well :P` to the file. By using the >> operator, the new text will be appended to the end of the file.

!git checkout greetings_YOURNAME
!echo "Greetings from Melih! I am waiting for the merge conflict as well :P" >> greetings.txt

Lets repeat the Let's repeat the same steps: move the changes from the **working directory** to the **staging area**, and then commit them to the **repository**.
!git add .
!git commit -m "Edit the greetings.txt file to include greetings from Melih"
At this point, we have made changes to the same line in the `greetings.txt` file on both the `main` branch and the `greetings_YOURNAME` branch. This simulates a real-world scenario where two developers make changes to the same line of code without knowing about each other's edits. 

When we try to merge the branches, Git will detect a **merge conflict** and ask us to resolve it manually. This happens because Git cannot decide which change to prioritize. Should the last change win? Should one developer's changes always take precedence? Or should the changes from the `main` branch always be kept? These decisions depend on the projectâ€™s context and cannot be made automatically by Git, which is why manual resolution is required.

---

To merge the `greetings_YOURNAME` branch into the `main` branch, follow these steps:

1. Ensure you are on the branch you want to merge changes **into**. In this case, we need to switch to the `main` branch:
   ```bash
   git checkout main
    ```

2. Merge the `greetings_YOURNAME` branch into the `main` branch:
    ```bash
    git merge greetings_YOURNAME
     ```
    
    When you attempt to merge the branches, Git will detect the conflict and display a message indicating that the merge was unsuccessful due to a conflict. The message will prompt you to resolve the conflict manually.
!git checkout main
!git merge greetings_YOURNAME
As you can see from the output, auto-merging failed. Git was unable to automatically merge the changes because of a conflict in the `greetings.txt` file. This happens when changes made to the same lines in both branches cannot be reconciled without human intervention.

Git marks the conflicting lines in the file with **conflict markers**:
- `<<<<<<<`: Marks the beginning of the changes from the current branch (in this case, the `main` branch).
- `=======`: Separates the changes from the two branches.
- `>>>>>>>`: Marks the beginning of the changes from the other branch (in this case, the `greetings_YOURNAME` branch).

The lines between these markers represent the conflicting changes. You need to decide which changes to keep and remove the conflict markers.

---

### Steps to Resolve the Conflict

1. **View the File**:
   First, check the contents of the file to understand the conflict:
   ```bash
   cat greetings.txt
    ```

2. **Edit the File**:
    Open the file in a text editor and view the conflict markers.

3. **Resolve the Conflict**:
    Decide which changes to keep:
        â€¢	Keep one branchâ€™s changes.
        â€¢	Combine both changes.
        â€¢	Write entirely new content.
    
    In this case, we will keep the changes from the `main` branch and remove the conflicting changes from the `greetings_YOURNAME` branch. Remove the conflict markers and unnecessary content to resolve the conflict.

4. **Add the Changes**:
    After resolving the conflict, add the changes to the staging area:
    ```bash
    git add greetings.txt
    ```

5. **Commit the Changes**:
    Commit the changes with a message indicating that the conflict has been resolved:
    ```bash
    git commit -m "Resolve the merge conflict and retain the changes from the main branch"
    ```

Now the merge conflict has been resolved, and the branches have been successfully merged!


!cat greetings.txt
<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/Pqp2Wtvg9CTXqRJ/download" alt="merge" width="800"/>
</div>

Demonstration of the merge conflict message and conflict markers in the `greetings.txt` file. The conflict markers indicate the conflicting changes from the `main` branch and the `greetings_YOURNAME` branch.

At this stage, we assume you have successfully resolved the merge conflict. Now, you can check the status of the repository using the `git status` command to verify the state of the working directory and staging area.
!git add .
!git status
As you can see, the output states that all conflicts have been fixed, but the merging process is not yet complete. Git prompts us to use the `git commit` command to conclude the merge.
!git commit -m "Resolve the merge conflict and retain the changes from the main branch"
!git status
!git log
!cat greetings.txt
## 4.5 Pull Requests

<div style="text-align: center;">
  <img src="https://www.svgrepo.com/show/431022/git-pull-request.svg" alt="merge" width="200"/>
</div>

<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/PfXfVx1uuDLyzKG/download" alt="merge" width="800"/>
</div>


**Pull requests** are a way to propose changes to a repository and collaborate on them. They allow you to submit your changes for review and approval before they are merged into the repository.

Imagine you're creating an international cookbook and it's your responsibility to add new recipes. You also want others to suggest recipes from their own cultures, but you need to ensure:
- The recipes are accurate.
- They use the correct ingredients.
- They follow a consistent format.
- They meet the cookbookâ€™s quality standards.

To achieve this, you donâ€™t allow others to directly add their recipes. Instead, you ask them to submit their recipes to you for review. You evaluate the recipes, ensure they meet the standards, and then add them to the cookbook. 

This process is similar to how **pull requests** work in Git. A pull request is a proposal to merge changes into a repository:
- The repository maintainers review the changes.
- Feedback is provided, if needed.
- Changes are merged into the repository once approved.

The term "pull request" reflects that youâ€™re requesting the maintainers to **pull** your changes into the repositoryâ€”similar to requesting cookbook maintainers to incorporate your recipe. Thas's why it's called a pull request not a push request.

---

You can create a pull request through a Git hosting service like GitHub, GitLab, or Bitbucket. For a demonstration, visit the [info1_remote repository](https://github.com/melihcatal/info1_remote/pull/2) on GitHub. 

Youâ€™ll see:
- A pull request to merge changes from the `greetings_YOURNAME` branch into the `main` branch.
- The changes made to the `greetings.txt` file.
- The commit messages and discussions between collaborators.

This illustrates how pull requests enable collaboration.

---

Although the outcome of a pull request is the same as merging branches directly, pull requests provide a structured workflow:
- Changes can be reviewed and discussed.
- Automated tests can be run.
- Code quality can be assessed.

Pull requests are widely used in software development to ensure the quality, consistency, and maintainability of the codebase.


<div style="text-align: center;">
    <img src="https://drive.switch.ch/index.php/s/andxf5uqSwUiVUr/download" alt="merge" width="900"/>

</div>
# 5. Exclude Files from Git

To keep your Git repository clean and efficient, itâ€™s important to exclude unnecessary files. Examples of files that should not be tracked by Git include:

- Temporary files
- Compile-time logs
- Build outputs
- Large or sensitive data, such as API keys or personal credentials

You can manage this effectively using a **`.gitignore`** file, which tells Git to ignore specified files or folders.

---

### Setting Up a `.gitignore` File

1. **Create it Early**:
   - Set up the `.gitignore` file at the start of your project to avoid tracking unnecessary files.
   - Ideally, initialize your Git repository **after** creating the `.gitignore` file.

2. **Manually Untrack Files**:
   - If unwanted files are already being tracked, untrack them using:
     ```bash
     git rm --cached <file>
     ```

3. **Use Pre-configured Options**:
   - When creating a new repository on platforms like GitHub, you can choose to include a pre-configured `.gitignore` file tailored for specific languages or frameworks.

---

### Simplifying `.gitignore` Creation

Tools like [gitignore.io](https://www.toptal.com/developers/gitignore/) can generate a tailored `.gitignore` file for your project. Customize the generated file to include exclusions specific to your workflow, such as:

- Temporary files (`*.log`, `*.tmp`)
- Build artifacts (`/dist/`, `/build/`)
- Sensitive data (`.env`, API key files)
- Large files or libraries (`*.zip`, `/node_modules/`)

---

### Best Practices for Using `.gitignore`

- **Start Early**: Include a `.gitignore` file from the beginning to avoid unnecessary files being added to the repository.
- **Review and Update**: Regularly update the `.gitignore` file as your project evolves.
- **Avoid Sensitive Data**: Never commit sensitive information; use `.gitignore` to prevent such files from being tracked.
- **Use Templates**: Take advantage of community or tool-generated templates for common frameworks and languages.

By following these practices, you can maintain a clean and organized codebase while avoiding unnecessary clutter in your Git repository.
Letâ€™s see how `.gitignore` works in practice. First, we create a new file, `hello.txt`, that we want to exclude from Git. Then, we create a .gitignore file and add hello.txt to it. Finally, we check the status of the repository to confirm that the hello.txt file is excluded from Git.
!echo "hello, please ignore this file" > hello.txt
Letâ€™s check if the `hello.txt` file exists in the working directory. We can use the `ls` command to list the files and directories in the current directory. The output should include the `hello.txt` file.

Next, letâ€™s view the contents of the file using the `cat` command to ensure it was created successfully.
!ls
!cat hello.txt
Now, letâ€™s check the Git status. We should see the `hello.txt` file listed as an **untracked file**. This means that Git successfully detects the file, but it is not currently being tracked. 

As weâ€™ve seen before, Git expects you to move untracked files from the working directory to the staging area and then to the repository. However, in this case, we donâ€™t want to track the `hello.txt` file. Instead, we want to exclude it from Gitâ€™s tracking. If we don't exclude it, Git will continue to detect and list the file as untracked. We wouldn't be able to use `git add .` to stage all changes, as it would include the `hello.txt` file.

To achieve this, we can create a `.gitignore` file and add `hello.txt` to it. The `.gitignore` file specifies files and directories that Git should ignore, ensuring they are not tracked in the repository.
!git status
Now, we create a `.gitignore` file and add the `hello.txt` file to it. Once the `.gitignore` file is created, letâ€™s check the output of `git status` again. The `hello.txt` file should no longer appear as an untracked file, as Git will now ignore it based on the rules defined in the `.gitignore` file.
!echo "hello.txt" > .gitignore
!git status
You see? Now the `hello.txt` file is no longer listed in the output of `git status`. It has been successfully excluded from Git tracking. 

Currently, only the `.gitignore` file is shown as **untracked**. We can add this file to the staging area and commit it to the repository to ensure the ignore rules are preserved.
!git add .gitignore
!git commit -m "Add .gitignore file"
!git status
We check the status of the repository again. The output should say: **nothing to commit, working tree clean**. This indicates that the `.gitignore` file has been successfully added to the repository and the working directory is clean.

The `hello.txt` file has been successfully excluded from Git. This does not mean the file was deletedâ€”it is still present in the working directory. It is simply not being tracked by Git.

If you ever want to track the file again, you can remove it from the `.gitignore` file and then add it to the staging area.
!ls
# 6. Conclusion

That's it! Youâ€™ve now learned the fundamental concepts and commands of Git, equipping you to manage your projects efficiently. Git is a powerful version control system that allows you to track changes, collaborate seamlessly, and maintain a clean and organized codebase.

While there is much more to explore in Git, the concepts and commands covered here are the ones youâ€™ll encounter most frequently in your daily work. This guide provides you with a solid foundation to grow and expand your Git skills.

Thank you for staying with us through this lecture! We hope you found it helpful and informative. Happy coding, and may your commits be meaningful! ðŸ˜„
# 7. Further Reading

The following topics will not be part of your exam and exercises, but you may find them useful for your future projects and career.
## 7.1 Fetch vs. Pull

**Fetch** and **pull** are two Git commands used to update your local repository with changes from a remote repository. The key difference between them lies in how they handle these updates:

- **`git fetch`**:  
  - Downloads changes from the remote repository to your local repository.  
  - Does not modify your working directory or current branch.  
  - Allows you to review the changes before deciding to `merge` them.  
  - Safe for inspecting updates without affecting your work.

- **`git pull`**:  
  - Combines the `git fetch` and `git merge` commands.  
  - Downloads changes from the remote repository and immediately merges them into your current branch.  
  - Can lead to conflicts if there are changes in the remote repository that conflict with your local changes.  

---

- **When to use `git fetch`**:  
  If you want to see whatâ€™s new on the remote repository without modifying your local repository. This is ideal for reviewing updates before integrating them.

- **When to use `git pull`**:  
  If you want to update your working directory immediately with the latest changes from the remote repository. This is convenient but can result in merge conflicts if there are conflicting changes.

By understanding the difference between fetch and pull, you can choose the appropriate command based on your workflow and avoid unnecessary conflicts.

!git fetch
!git log origin/main
## 7.2 Rebasing vs. Merging

<div style="text-align: center;">
  <img src="https://drive.switch.ch/index.php/s/i1zcyCY3nGfI7Oz/download" alt="merge" width="400"/>
  <img src="https://drive.switch.ch/index.php/s/TjitDemg97RovK9/download" alt="rebase" width="400"/>
</div>

Both **rebase** and **merge** are Git commands used to integrate changes from one branch into another. However, they differ in how they handle commit history:

- **Rebase**:  
  - Moves the commits from one branch to another and rewrites the commit history to create a clean, linear history.  
  - Eliminates unnecessary merge commits.  
  - Ideal for maintaining a tidy and readable commit history.  
  - **Be cautious**: Rebase rewrites history, which can lead to conflicts and issues if used on branches already shared with others.  

- **Merge**:  
  - Combines the changes from two branches by creating a new **merge commit**.  
  - Preserves the complete commit history of both branches.  
  - Ideal for preserving the context of branch history in collaborative environments.  

---

#### When to Use Rebase or Merge

- Use **rebase**:
  - To keep the commit history clean and linear.  
  - On **local branches** that have not been shared with others.  

- Use **merge**:
  - To preserve the commit history of all branches.  
  - For **branches already shared with others**, to avoid rewriting history and causing conflicts.  

---

#### Key Differences

| Feature           | Rebase                                   | Merge                                  |
|-------------------|------------------------------------------|----------------------------------------|
| Commit History    | Rewrites history to be linear            | Preserves full branch commit history   |
| New Commit        | Does not create a new merge commit       | Creates a new merge commit             |
| Use Case          | Clean, linear history                   | Collaborative environments             |
| Safety            | Destructive (rewrites history)          | Non-destructive                        |

---

#### Important Note
Rebase is a **destructive operation**, and itâ€™s recommended to use it carefully, especially on private branches. Avoid rebasing public branches to prevent conflicts for collaborators.

For more details, refer to the [documentation](https://www.atlassian.com/git/tutorials/merging-vs-rebasing).
Let's see how we can rebase the `greetings_YOURNAME` branch onto the `main` branch. Rebasing rewrites the commit history by applying the commits of one branch onto another, creating a clean, linear history.

---

#### Steps to Rebase the `greetings_YOURNAME` Branch onto `main`

1. **Switch to the `main` branch**:
   Use the `git checkout` command to switch to the `main` branch:
   ```bash
   git checkout main
    ```
2. **Rebase the `greetings_YOURNAME` branch onto `main`**:
    Use the `git rebase` command followed by the branch name to rebase the `greetings_YOURNAME` branch onto the `main` branch:
    ```bash
    git rebase greetings_YOURNAME
     ```

    The template for the `git rebase` command is:
     ```bash
        git rebase <branch_name>
     ```
    This applies the commits from the specified branch onto the current branch.


!git checkout greetings_YOURNAME
!git log
!git log --oneline --graph --all
!git rebase main
As you can see, the `greetings_YOURNAME` branch has now been successfully rebased onto the `main` branch. The changes from the `greetings_YOURNAME` branch are applied on top of the `main` branch, creating a clean and linear commit history.

Rebasing is particularly useful when you want to maintain a tidy commit history and eliminate unnecessary merge commits. However, remember that rebase is a **destructive operation** as it rewrites commit history. Use it carefully, especially on branches shared with others.
!git log
!git log --oneline --graph --all